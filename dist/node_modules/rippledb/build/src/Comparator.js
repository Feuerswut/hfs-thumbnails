"use strict";

exports.__esModule = true;
exports.BytewiseComparator = void 0;

var _DBHelper = require("./DBHelper");

/**
 * Copyright (c) 2018-present, heineiuo.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class BytewiseComparator {
  getName() {
    return "leveldb.BytewiseComparator";
  }

  compare(a, b) {
    return a.compare(b);
  }

  findShortestSeparator(start, limit) {
    // Find length of common prefix
    const minLength = Math.min(start.length, limit.size);
    let diffIndex = 0;

    while (diffIndex < minLength && start.buffer[diffIndex] == limit.buffer[diffIndex]) {
      diffIndex++;
    }

    if (diffIndex >= minLength) {// Do not shorten if one string is a prefix of the other
    } else {
      const diffByte = start.buffer[diffIndex];

      if (diffByte < 0xff && diffByte + 1 < limit.buffer[diffIndex]) {
        start.buffer[diffIndex]++;
        start.buffer = start.buffer.slice(0, diffIndex + 1);
        (0, _DBHelper.assert)(this.compare(start, limit) < 0);
      }
    }
  }

  findShortSuccessor(key) {
    // Find first character that can be incremented
    const n = key.length;

    for (let i = 0; i < n; i++) {
      const byte = key.buffer[i];

      if (byte != 0xff) {
        key.buffer[i] = byte + 1;
        key.buffer = key.buffer.slice(0, i + 1);
        return;
      }
    } // *key is a run of 0xffs.  Leave it alone.

  }

}

exports.BytewiseComparator = BytewiseComparator;
//# sourceMappingURL=Comparator.js.map