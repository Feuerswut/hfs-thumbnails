"use strict";

exports.__esModule = true;
exports.WriteBatch = exports.WriteBatchInternal = void 0;

var _Buffer = require("./Buffer");

var _DBHelper = require("./DBHelper");

var _Slice = _interopRequireDefault(require("./Slice"));

var _LogRecord = _interopRequireDefault(require("./LogRecord"));

var _Format = require("./Format");

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class WriteBatchInternal {
  // WriteBatch header has an 8-byte sequence number followed by a 4-byte count.
  static byteSize(batch) {
    return batch.buffers.reduce((size, buf) => size + buf.length, 0);
  }

  static insert(batch, mem) {
    let nextSequence = WriteBatchInternal.getSequence(batch);

    for (const update of batch.iterator()) {
      const {
        type,
        key,
        value
      } = update;
      mem.add(nextSequence, type, key, value);
      nextSequence += 1n;
    }
  }

  static getContents(batch) {
    return _Buffer.Buffer.concat([batch.head, ...batch.buffers]);
  }

  static setContents(batch, contents) {
    (0, _DBHelper.assert)(contents.length >= WriteBatchInternal.kHeader);
    batch.head = contents.slice(0, this.kHeader);
    batch.buffers = [contents.slice(this.kHeader)];
  } // sequence must be lastSequence + 1


  static setSequence(batch, sequence) {
    batch.head.fillBuffer((0, _Coding.encodeFixed64)(sequence), 0, 7);
  }

  static getSequence(batch) {
    return (0, _Coding.decodeFixed64)(batch.head.slice(0, 8));
  }

  static setCount(batch, count) {
    batch.head.fillBuffer((0, _Coding.encodeFixed32)(count), 8, 11);
  }

  static getCount(batch) {
    return (0, _Coding.decodeFixed32)(batch.head.slice(8, 12));
  }

  static append(dst, src) {
    WriteBatchInternal.setCount(dst, WriteBatchInternal.getCount(src) + WriteBatchInternal.getCount(dst)); // for (const buf of src.buffers) {
    //   dst.buffers.push(buf)
    // }

    dst.buffers = dst.buffers.concat(src.buffers);
  }

} // Simplified WriteBatch
// WriteBatch::rep_ :=
//    sequence: fixed64
//    count: fixed32
//    data: record[count]
// record :=
//    kTypeValue varstring varstring         |
//    kTypeDeletion varstring
// varstring :=
//    len: varint32
//    data: uint8[len]


exports.WriteBatchInternal = WriteBatchInternal;

_defineProperty(WriteBatchInternal, "kHeader", 12);

class WriteBatch {
  constructor() {
    _defineProperty(this, "buffers", []);

    _defineProperty(this, "head", _Buffer.Buffer.alloc(WriteBatchInternal.kHeader));
  }

  put(key, value) {
    const record = _LogRecord.default.add(new _Slice.default(key), new _Slice.default(value));

    this.buffers.push(record.buffer);
    WriteBatchInternal.setCount(this, WriteBatchInternal.getCount(this) + 1);
  }

  del(key) {
    const record = _LogRecord.default.del(new _Slice.default(key));

    this.buffers.push(record.buffer);
    WriteBatchInternal.setCount(this, WriteBatchInternal.getCount(this) + 1);
  }

  clear() {
    this.buffers = [];
    this.head = _Buffer.Buffer.alloc(WriteBatchInternal.kHeader);
  }

  *iterator() {
    let buffersIndex = 0;
    const buffersCount = this.buffers.length;

    while (buffersIndex < buffersCount) {
      const buffer = this.buffers[buffersIndex];
      const bufferLength = buffer.length;
      let index = 0;

      while (index < bufferLength) {
        const valueType = buffer.readUInt8(index);
        index++;

        const keyLength = _DBHelper.varint.decode(buffer, index);

        index += _DBHelper.varint.decode.bytes;
        const keyBuffer = buffer.slice(index, index + keyLength);
        index += keyLength;

        if (valueType === _Format.ValueType.kTypeDeletion) {
          yield {
            type: valueType,
            key: new _Slice.default(keyBuffer),
            value: new _Slice.default()
          };
          continue;
        }

        const valueLength = _DBHelper.varint.decode(buffer, index);

        index += _DBHelper.varint.decode.bytes;
        const valueBuffer = buffer.slice(index, index + valueLength);
        index += valueLength;
        yield {
          type: valueType,
          key: new _Slice.default(keyBuffer),
          value: new _Slice.default(valueBuffer)
        };
      }

      buffersIndex++;
    }
  }

}

exports.WriteBatch = WriteBatch;
//# sourceMappingURL=WriteBatch.js.map