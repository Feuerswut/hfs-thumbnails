"use strict";

exports.__esModule = true;
exports.CompactionState = exports.CompactionStats = exports.default = void 0;

var _VersionEdit = _interopRequireDefault(require("./VersionEdit"));

var _Format = require("./Format");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Compaction {
  static targetFileSize(options) {
    return options.maxFileSize;
  }

  static maxGrandParentOverlapBytes(options) {
    return 10 * Compaction.targetFileSize(options);
  }

  static totalFileSize(files) {
    let sum = 0;

    for (const file of files) {
      sum += file.fileSize;
    }

    return sum;
  } // eslint-disable-next-line


  static maxFileSizeForLevel(options, level) {
    // We could vary per level to reduce number of files?
    return Compaction.targetFileSize(options);
  }

  constructor(options, level) {
    _defineProperty(this, "level", void 0);

    _defineProperty(this, "inputVersion", void 0);

    _defineProperty(this, "grandparents", void 0);

    _defineProperty(this, "edit", void 0);

    _defineProperty(this, "inputs", void 0);

    _defineProperty(this, "grandparentIndex", void 0);

    _defineProperty(this, "seenKey", void 0);

    _defineProperty(this, "overlappedBytes", void 0);

    _defineProperty(this, "_maxOutputFilesize", void 0);

    _defineProperty(this, "levelPtrs", void 0);

    this.level = level;
    this.grandparentIndex = 0;
    this.overlappedBytes = 0;
    this.seenKey = false;
    this.inputs = [[], []];
    this._maxOutputFilesize = Compaction.maxFileSizeForLevel(options, level);
    this.levelPtrs = Array.from({
      length: _Format.Config.kNumLevels
    }, () => 0);
    this.edit = new _VersionEdit.default();
  }

  get maxOutputFilesize() {
    return this._maxOutputFilesize;
  }

  numInputFiles(which) {
    return this.inputs[which].length;
  } // Is this a trivial compaction that can be implemented by just
  // moving a single input file to the next level (no merging or splitting)


  isTrivialMove() {
    const versionSet = this.inputVersion.versionSet; // Avoid a move if there is lots of overlapping grandparent data.
    // Otherwise, the move could create a parent file that will require
    // a very expensive merge later on.

    return this.numInputFiles(0) === 1 && this.numInputFiles(1) === 0 && Compaction.totalFileSize(this.grandparents) <= Compaction.maxGrandParentOverlapBytes(versionSet._options);
  } // Returns true if the information we have available guarantees that
  // the compaction is producing data in "level+1" for which no data exists
  // in levels greater than "level+1".


  isBaseLevelForKey(userKey) {
    const userComparator = this.inputVersion.versionSet.internalKeyComparator.userComparator;

    for (let level = this.level + 2; level < _Format.Config.kNumLevels; level++) {
      const files = this.inputVersion.files[level];

      while (this.levelPtrs[level] < files.length) {
        const f = files[this.levelPtrs[level]];

        if (userComparator.compare(userKey, f.largest.userKey) <= 0) {
          // We've advanced far enough
          if (userComparator.compare(userKey, f.smallest.userKey) >= 0) {
            // Key falls in this file's range, so definitely not base level
            return false;
          }

          break;
        }

        this.levelPtrs[level]++;
      }
    }

    return true;
  } // Release the input version for the compaction, once the compaction
  // is successful.


  releaseInputs() {
    if (!!this.inputVersion) {
      this.inputVersion.unref();
      delete this.inputVersion;
    }
  }
  /**
   * Returns true if we should stop building the current output
   * before processing "internalKey".
   */


  shouldStopBefore(internalKey) {
    const versionSet = this.inputVersion.versionSet;
    const icmp = versionSet.internalKeyComparator;

    while (this.grandparentIndex < this.grandparents.length && icmp.compare(internalKey, this.grandparents[this.grandparentIndex].largest) > 0) {
      if (this.seenKey) {
        this.overlappedBytes += this.grandparents[this.grandparentIndex].fileSize;
      }

      this.grandparentIndex++;
    }

    this.seenKey = true;

    if (this.overlappedBytes > Compaction.maxGrandParentOverlapBytes(versionSet._options)) {
      this.overlappedBytes = 0;
      return true;
    } else {
      return false;
    }
  } // Add all inputs to this compaction as delete operations to *edit.


  addInputDeletions(edit) {
    for (let which = 0; which < 2; which++) {
      for (let i = 0; i < this.inputs[which].length; i++) {
        edit.deleteFile(this.level + which, this.inputs[which][i].number);
      }
    }
  }

}

exports.default = Compaction;

class CompactionStats {
  constructor() {
    _defineProperty(this, "times", void 0);

    _defineProperty(this, "bytesRead", void 0);

    _defineProperty(this, "bytesWritten", void 0);

    this.times = 0;
    this.bytesRead = 0;
    this.bytesWritten = 0;
  }

  add(c) {
    this.times += c.times;
    this.bytesRead += c.bytesRead;
    this.bytesWritten += c.bytesWritten;
  }

}

exports.CompactionStats = CompactionStats;

class CompactionState {
  constructor(c) {
    _defineProperty(this, "outputs", []);

    _defineProperty(this, "smallestSnapshot", void 0);

    _defineProperty(this, "compaction", void 0);

    _defineProperty(this, "outfile", void 0);

    _defineProperty(this, "builder", void 0);

    _defineProperty(this, "totalBytes", void 0);

    this.compaction = c;
    this.smallestSnapshot = 0n;
    this.totalBytes = 0;
  }

  currentOutput() {
    return this.outputs[this.outputs.length - 1];
  }

}

exports.CompactionState = CompactionState;
//# sourceMappingURL=Compaction.js.map