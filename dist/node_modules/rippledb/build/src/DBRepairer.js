"use strict";

exports.__esModule = true;
exports.InternalDBRepairer = void 0;

var _Options = require("./Options");

var _Filename = require("./Filename");

var _Format = require("./Format");

var _LogReader = _interopRequireDefault(require("./LogReader"));

var _MemTable = _interopRequireDefault(require("./MemTable"));

var _WriteBatch = require("./WriteBatch");

var _VersionFormat = require("./VersionFormat");

var _Builder = require("./Builder");

var _SSTableCache = require("./SSTableCache");

var _SSTableBuilder = _interopRequireDefault(require("./SSTableBuilder"));

var _VersionEdit = _interopRequireDefault(require("./VersionEdit"));

var _LogWriter = _interopRequireDefault(require("./LogWriter"));

var _VersionEditRecord = _interopRequireDefault(require("./VersionEditRecord"));

var _DBHelper = require("./DBHelper");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InternalDBRepairer {
  constructor(dbpath, originalOptions) {
    _defineProperty(this, "_env", void 0);

    _defineProperty(this, "_icmp", void 0);

    _defineProperty(this, "_manifests", void 0);

    _defineProperty(this, "_logs", void 0);

    _defineProperty(this, "_tables", void 0);

    _defineProperty(this, "_tableInfos", void 0);

    _defineProperty(this, "_dbpath", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_nextFileNumber", void 0);

    _defineProperty(this, "_tableCache", void 0);

    _defineProperty(this, "_edit", void 0);

    if (!originalOptions.env) throw new Error("env required");
    const env = originalOptions.env;
    this._dbpath = dbpath;
    this._options = { ..._Options.defaultOptions,
      ...originalOptions,
      env
    };
    this._manifests = [];
    this._logs = [];
    this._icmp = new _Format.InternalKeyComparator(this._options.comparator);
    this._tables = [];
    this._env = this._options.env;
    this._nextFileNumber = 1;
    this._tableCache = new _SSTableCache.TableCache(dbpath, this._options, 10);
    this._tableInfos = [];
    this._edit = new _VersionEdit.default();
  }

  async run() {
    let error;
    error = await this.findFiles();

    if (!error) {
      await this.convertLogFilesToTables();
      await this.extractMetaData();
      error = await this.writeDescriptor();
    }

    if (!error) {
      let bytes = 0;

      for (const tableInfo of this._tableInfos) {
        bytes += tableInfo.meta.fileSize;
      }

      await this._options.log(`**** Repaired leveldb ${this._dbpath}; 
recovered ${this._tableInfos.length} files; ${bytes} bytes. 
Some data may have been lost. 
****`);
    }

    if (this._options.debug && error) {
      console.log(error);
    }

    return error;
  }

  async findFiles() {
    const filenames = (await this._options.env.readdir(this._dbpath)).reduce((filenames, dirent) => {
      if (dirent.isFile()) {
        filenames.push(dirent.name);
      }

      return filenames;
    }, []);

    if (filenames.length === 0) {
      throw new Error("DBRepairer found no files");
    }

    for (const filename of filenames) {
      const parsedFile = (0, _Filename.parseFilename)(filename);

      if (parsedFile.type === _Format.FileType.kDescriptorFile) {
        this._manifests.push(filename);
      } else {
        if (parsedFile.number + 1 > this._nextFileNumber) {
          this._nextFileNumber = parsedFile.number + 1;
        }

        if (parsedFile.type === _Format.FileType.kLogFile) {
          this._logs.push(parsedFile.number);
        } else if (parsedFile.type === _Format.FileType.kTableFile) {
          this._tables.push(parsedFile.number);
        } else {// Ignore other files
        }
      }
    }
  }

  async convertLogFilesToTables() {
    for (const logFileNumber of this._logs) {
      const logFilename = (0, _Filename.getLogFilename)(this._dbpath, logFileNumber);

      try {
        await this.convertLogToTable(logFileNumber);
      } catch (e) {
        this._options.log(`Log #${logFileNumber}: Ignoring conversion error: ${e.message}`);
      } finally {
        this.archiveFile(logFilename);
      }
    }
  }

  async convertLogToTable(logNumber) {
    const logFilename = (0, _Filename.getLogFilename)(this._dbpath, logNumber);
    const reader = new _LogReader.default(await this._options.env.open(logFilename, "r"));
    const mem = new _MemTable.default(this._icmp);
    mem.ref();

    for await (const record of reader.iterator()) {
      if (record.size < 12) {
        this._options.log(` ${logFilename} log record too small: dropping ${record.size} bytes`);

        continue;
      }

      try {
        const batch = new _WriteBatch.WriteBatch();

        _WriteBatch.WriteBatchInternal.setContents(batch, record.buffer);

        _WriteBatch.WriteBatchInternal.insert(batch, mem);
      } catch (e) {
        this._options.log(`Log #${logNumber}: Ignoring ${e.message}`);
      }
    }

    await reader.close();
    const meta = new _VersionFormat.FileMetaData();
    meta.number = this._nextFileNumber++;
    const status = await (0, _Builder.buildTable)(this._dbpath, this._env, this._options, mem.iterator(), meta);
    mem.unref();

    if (await status.ok()) {
      if (meta.fileSize > 0) {
        this._tables.push(meta.number);
      }
    }

    this._options.log(`Log #${logNumber}: ops saved to Table #${meta.number} ${status.message}`);
  }

  async archiveFile(filename) {
    // Move into another directory.  E.g., for
    //    dir/foo
    // rename to
    //    dir/lost/foo
    const slashIndex = filename.lastIndexOf("/");
    const lostDir = filename.substr(0, slashIndex) + "/lost";

    try {
      await this._env.mkdir(lostDir);
    } catch (e) {}

    const newFilename = lostDir + filename.substr(slashIndex);
    await this._env.rename(filename, newFilename);

    this._options.log(`Archiving ${filename}: ${newFilename}`);
  }

  async extractMetaData() {
    for (const tableNumber of this._tables) {
      await this.scanTable(tableNumber);
    }
  }

  async scanTable(tableNumber) {
    const tableInfo = {
      meta: new _VersionFormat.FileMetaData(),
      maxSequence: 0n
    };
    tableInfo.meta.number = tableNumber;
    const tableFilename = (0, _Filename.getTableFilename)(this._dbpath, tableNumber);

    try {
      tableInfo.meta.fileSize = await this._env.getFileSize(tableFilename);
    } catch (e) {
      try {
        await this.archiveFile(tableFilename);
      } catch (e) {}
    } // Extract metadata by scanning through table.


    let counter = 0;
    let empty = true;
    const options = {};
    const parsed = new _Format.ParsedInternalKey();
    let error;

    try {
      for await (const entry of this._tableCache.entryIterator(options, tableInfo.meta.number, tableInfo.meta.fileSize)) {
        if (!(0, _Format.parseInternalKey)(entry.key, parsed)) {
          this._options.log(`Table #${tableInfo.meta.number}: unparseable key ${entry.key.toString()}`);

          continue;
        }

        counter++;

        if (empty) {
          empty = false;
          tableInfo.meta.smallest.decodeFrom(entry.key);
        }

        tableInfo.meta.largest.decodeFrom(entry.key);

        if (parsed.sn > tableInfo.maxSequence) {
          tableInfo.maxSequence = parsed.sn;
        }
      }
    } catch (e) {
      console.error(e);
      error = e;
    }

    this._options.log(`Table #${tableInfo.meta.number}: ${counter} entries ${error ? error.message : "success"}`);

    if (!error) {
      this._tableInfos.push(tableInfo);
    } else {
      this.repairTable(tableFilename, tableInfo); // RepairTable archives input file.
    }
  }

  async repairTable(srcTableFilename, tableInfo) {
    // We will copy src contents to a new table and then rename the
    // new table over the source.
    const destTableFilename = (0, _Filename.getTableFilename)(this._dbpath, this._nextFileNumber++);
    const fd = await this._env.open(destTableFilename, "a+");
    const tableBuilder = new _SSTableBuilder.default(this._options, fd);
    const options = {};
    let counter = 0;

    for await (const entry of this._tableCache.entryIterator(options, tableInfo.meta.number, tableInfo.meta.fileSize)) {
      await tableBuilder.add(entry.key, entry.value);
      counter++;
    }

    let error;

    try {
      await this.archiveFile(srcTableFilename);

      if (counter === 0) {
        await tableBuilder.abandon();
      } else {
        await tableBuilder.finish();
        tableInfo.meta.fileSize = tableBuilder.fileSize;
      }
    } catch (e) {
      error = e;
    } finally {
      try {
        if (counter > 0 && !error) {
          const orig = (0, _Filename.getTableFilename)(this._dbpath, tableInfo.meta.number);
          await this._env.rename(destTableFilename, orig);

          this._options.log(`Table #${tableInfo.meta.number}: ${counter} entries repaired`);
        }
      } catch (e) {
        error = e;
      } finally {
        if (error) {
          try {
            await this._env.unlink(destTableFilename);
          } catch (e) {}
        }
      }
    }

    return error;
  }

  async writeDescriptor() {
    const tempFilename = (0, _Filename.getTempFilename)(this._dbpath, 1);
    let error;
    let file;

    try {
      file = await this._env.open(tempFilename, "a+");
    } catch (e) {
      error = e;
    }

    if (error || !file) return;
    let maxSequence = 0n;

    for (const tableInfo of this._tableInfos) {
      if (maxSequence < tableInfo.maxSequence) {
        maxSequence = tableInfo.maxSequence;
      }
    }

    this._edit.comparator = this._icmp.userComparator.getName();
    this._edit.logNumber = 0;
    this._edit.nextFileNumber = this._nextFileNumber;
    this._edit.lastSequence = maxSequence;

    for (const tableInfo of this._tableInfos) {
      this._edit.addFile(0, tableInfo.meta.number, tableInfo.meta.fileSize, tableInfo.meta.smallest, tableInfo.meta.largest);
    }

    let writer;

    try {
      writer = new _LogWriter.default(file);
      await writer.addRecord(_VersionEditRecord.default.add(this._edit));
    } catch (e) {
      error = e;
    }

    if (!error && writer) {
      await writer.close();
    }

    if (error) {
      await this._env.unlink(tempFilename);
    } else {
      try {
        for (const manifest of this._manifests) {
          await this.archiveFile(_DBHelper.path.resolve(this._dbpath, manifest));
        } // Install new manifest


        this._env.rename(tempFilename, (0, _Filename.getManifestFilename)(this._dbpath, 1));
      } catch (e) {
        error = e;
      }

      if (error) {
        this._env.unlink(tempFilename);
      } else {
        await (0, _Filename.setCurrentFile)(this._env, this._dbpath, 1);
      }
    }

    return error;
  }

}

exports.InternalDBRepairer = InternalDBRepairer;
//# sourceMappingURL=DBRepairer.js.map