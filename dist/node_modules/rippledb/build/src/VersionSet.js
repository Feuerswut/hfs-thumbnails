"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Version = _interopRequireDefault(require("./Version"));

var _Filename = require("./Filename");

var _Slice = _interopRequireDefault(require("./Slice"));

var _VersionFormat = require("./VersionFormat");

var _Status = _interopRequireDefault(require("./Status"));

var _VersionBuilder = _interopRequireDefault(require("./VersionBuilder"));

var _VersionEditRecord = _interopRequireDefault(require("./VersionEditRecord"));

var _LogReader = _interopRequireDefault(require("./LogReader"));

var _VersionEdit = _interopRequireDefault(require("./VersionEdit"));

var _Format = require("./Format");

var _LogWriter = _interopRequireDefault(require("./LogWriter"));

var _Compaction = _interopRequireDefault(require("./Compaction"));

var _Merger = _interopRequireDefault(require("./Merger"));

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class VersionSet {
  // Per-level key at which the next compaction at that level should start.
  // Either an empty string, or a valid InternalKey.
  // Return the log file number for the log file that is currently
  // being compacted, or zero if there is no such log file.
  // if prevLogNumber is 0, then no log file is being compacted
  constructor(dbpath, options, tableCache, internalKeyComparator) {
    _defineProperty(this, "compactPointers", void 0);

    _defineProperty(this, "_current", void 0);

    _defineProperty(this, "_dummyVersions", void 0);

    _defineProperty(this, "hasLogNumber", void 0);

    _defineProperty(this, "hasNextFileNumber", void 0);

    _defineProperty(this, "hasPrevLogNumber", void 0);

    _defineProperty(this, "logNumber", 0);

    _defineProperty(this, "prevLogNumber", 0);

    _defineProperty(this, "_lastSequence", 0n);

    _defineProperty(this, "hasLastSequence", void 0);

    _defineProperty(this, "manifestFileNumber", 0);

    _defineProperty(this, "nextFileNumber", 2);

    _defineProperty(this, "_dbpath", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "internalKeyComparator", void 0);

    _defineProperty(this, "tableCache", void 0);

    _defineProperty(this, "manifestWriter", void 0);

    _defineProperty(this, "recover", async () => {
      const result = {}; // read current， check if end of content is '\n'

      const current = await this._options.env.readFile((0, _Filename.getCurrentFilename)(this._dbpath), "utf8");

      if (!current || current[current.length - 1] !== "\n") {
        throw new Error("Invalid format of CURRENT file.");
      }

      let hasLogNumber = false;
      let hasNextFileNumber = false;
      let hasPrevLogNumber = false;
      let hasLastSequence = false;
      let logNumber = 0;
      let nextFileNumber = 0;
      let prevLogNumber = 0;
      let lastSequence = 0n;
      const builder = new _VersionBuilder.default(this, this._current);
      const currentValue = current.substr(0, current.length - 1);
      const manifestNumber = Number(currentValue.substr("MANIFEST-".length)); // Use current to read description file (manifest)

      const reader = new _LogReader.default(await this._options.env.open((0, _Filename.getManifestFilename)(this._dbpath, manifestNumber), "r")); // read record，apply to versionSet(apply method)
      // Update log number and prev log number（can be ignore because prev log number has
      // been deprecated in fact ）
      // Update next file
      // Update last sequence
      // Use version builder to create a new version

      for await (const editSlice of reader.iterator()) {
        const edit = _VersionEditRecord.default.decode(editSlice);

        builder.apply(edit); // Update manifest_file_number_， next_file_number_， last_sequence_， log_number_， prev_log_number_

        if (edit.hasLogNumber) {
          logNumber = edit.logNumber;
          hasLogNumber = true;
        }

        if (edit.hasPrevLogNumber) {
          prevLogNumber = edit.prevLogNumber;
          hasPrevLogNumber = true;
        }

        if (edit.hasNextFileNumber) {
          nextFileNumber = edit.nextFileNumber;
          hasNextFileNumber = true;
        }

        if (edit.hasLastSequence) {
          lastSequence = edit.lastSequence;
          hasLastSequence = true;
        }
      }

      if (!hasNextFileNumber) {
        throw new Error("no meta-nextfile entry in descriptor");
      } else if (!hasLogNumber) {
        throw new Error("no meta-lognumber entry in descriptor");
      } else if (!hasLastSequence) {
        throw new Error("no last-sequence-number entry in descriptor");
      }

      if (!hasPrevLogNumber) {
        prevLogNumber = 0;
      }

      this.markFileNumberUsed(prevLogNumber);
      this.markFileNumberUsed(logNumber); // put apply's result to version(use finalize method)

      const version = new _Version.default(this);
      builder.saveTo(version);
      this.finalize(version); // put version to version set(append version)

      this.appendVersion(version);
      this.manifestFileNumber = nextFileNumber;
      this.nextFileNumber = nextFileNumber + 1;
      this.lastSequence = lastSequence;
      this.logNumber = logNumber;
      this.prevLogNumber = prevLogNumber; // check if we can reuse manifest of need to create a new one
      // See if we can reuse the existing MANIFEST file.

      if (this.reuseManifest()) {// No need to save new manifest
      } else {
        result.saveManifest = true;
      }

      await reader.close();
      return result;
    });

    this._dbpath = dbpath;
    this._options = options;
    this.tableCache = tableCache;
    this.internalKeyComparator = internalKeyComparator;
    this._dummyVersions = new _Version.default(this);
    this.appendVersion(new _Version.default(this));
    this.compactPointers = [];
  }

  get lastSequence() {
    return this._lastSequence;
  }

  set lastSequence(value) {
    this._lastSequence = value;
  }

  get current() {
    return this._current;
  }

  getLevelSummary() {
    let summary = "files [ ";

    for (let i = 0; i < this._current.files.length; i++) {
      summary += `${this._current.files[i].length} `;
    }

    summary += "]";
    return summary;
  }

  compactRange(level, begin, end) {
    let inputs = this._current.getOverlappingInputs(level, begin, end);

    if (inputs.length === 0) return; // Avoid compacting too much in one shot in case the range is large.
    // But we cannot do this for level-0 since level-0 files can overlap
    // and we must not pick one file and drop another older file if the
    // two files overlap.

    if (level > 0) {
      const limit = this.maxFileSizeForLevel(this._options, level);
      let total = 0;

      for (let i = 0; i < inputs.length; i++) {
        total += inputs[i].fileSize;

        if (total >= limit) {
          inputs = inputs.slice(0, i + 1);
          break;
        }
      }
    }

    const compaction = new _Compaction.default(this._options, level);
    compaction.inputVersion = this._current;
    compaction.inputVersion.ref();
    compaction.inputs[0] = inputs;
    this.setupOtherInputs(compaction);
    return compaction;
  }

  maxFileSizeForLevel(options, level) {
    return options.maxFileSize;
  }

  getNextFileNumber() {
    return this.nextFileNumber++;
  }

  getNumLevelFiles(level) {
    (0, _DBHelper.assert)(level >= 0);
    (0, _DBHelper.assert)(level <= _Format.Config.kNumLevels);
    return this._current.files[level].length;
  }

  markFileNumberUsed(num) {
    if (this.nextFileNumber <= num) {
      this.nextFileNumber = num + 1;
    }
  } // Precomputed best level for next compaction


  finalize(ver) {
    // traverse levels(0-6),
    // calculate score，0 level use files number / 8（kLevel0MaxFileSize)
    // other level use file bytes / maxFileBytes * 10^level
    // if score > best_score（best_score initial value - 1）, Update best_score and best_level
    // when traverse end,  Update version's best_score and best_level
    let bestLevel = -1;
    let bestScore = -1;

    for (let level = 0; level < _Format.Config.kNumLevels; level++) {
      let score = 0;

      if (level === 0) {
        score = ver.files[level].length / _Format.Config.kL0CompactionTrigger;
      } else {
        const levelBytes = this.getTotalBytes(ver.files[level]);
        if (this._options.debug) this._options.log(`DEBUG level=${level} levelBytes=${levelBytes}`); // score >= 1 means size is bigger then limit

        score = levelBytes / (0, _VersionFormat.getMaxBytesForLevel)(level);
      }

      if (score > bestScore) {
        bestScore = score;
        bestLevel = level;
      }
    }

    ver.compactionLevel = bestLevel;
    ver.compactionScore = bestScore;
  }

  getTotalBytes(files) {
    let sum = 0;

    for (const f of files) {
      sum += f.fileSize;
    }

    return sum;
  } // append to manifest


  async logAndApply(edit) {
    if (edit.hasLogNumber) {
      (0, _DBHelper.assert)(edit.logNumber >= this.logNumber);
      (0, _DBHelper.assert)(edit.logNumber < this.nextFileNumber);
    } else {
      edit.logNumber = this.logNumber;
    }

    if (!edit.hasPrevLogNumber) {
      edit.prevLogNumber = this.prevLogNumber;
    }

    edit.nextFileNumber = this.nextFileNumber;
    edit.lastSequence = this.lastSequence;
    const ver = new _Version.default(this);
    const builder = new _VersionBuilder.default(this, this._current);
    builder.apply(edit);
    builder.saveTo(ver);
    this.finalize(ver); // Initialize new descriptor log file if necessary by creating
    // a temporary file that contains a snapshot of the current version.

    let manifestFilename = "";
    let status = new _Status.default();

    if (!this.manifestWriter) {
      // No reason to unlock *mu here since we only hit this path in the
      // first call to LogAndApply (when opening the database).
      manifestFilename = (0, _Filename.getManifestFilename)(this._dbpath, this.manifestFileNumber);
      edit.nextFileNumber = this.nextFileNumber;
      this.manifestWriter = new _LogWriter.default(await this._options.env.open(manifestFilename, "a"));
      if (this._options.debug) this._options.log("DEBUG writeSnapshot starting...");
      status = this.writeSnapshot(this.manifestWriter);
    }

    if (await status.ok()) {
      const record = _VersionEditRecord.default.add(edit);

      status = new _Status.default(this.manifestWriter.addRecord(record));
    } else {
      if (this._options.debug) this._options.log("DEBUG writeSnapshot fail");
    } // If we just created a new descriptor file, install it by writing a
    // new CURRENT file that points to it.


    if ((await status.ok()) && manifestFilename.length > 0) {
      status = new _Status.default(this.writeCurrentFile(this._dbpath, this.manifestFileNumber));
    } // Install the new version


    if (await status.ok()) {
      if (!!manifestFilename) {
        await this.manifestWriter.close();
        delete this.manifestWriter;
      }

      this._options.log("DEBUG LogAndApply success, Install the new version");

      this.appendVersion(ver);
      this.logNumber = edit.logNumber;
      this.prevLogNumber = edit.prevLogNumber;
    } else {
      this._options.log("DEBUG LogAndApply fail, Delete ver"); // delete ver


      if (!!manifestFilename) {
        await this.manifestWriter.close();
        delete this.manifestWriter;
        await this._options.env.unlink(manifestFilename);
      }
    }

    return status;
  }

  needsCompaction() {
    return this._current.compactionScore >= 1 || !!this._current.fileToCompact;
  }
  /**
   * update this._current
   */


  appendVersion(ver) {
    (0, _DBHelper.assert)(ver.refs === 0);
    (0, _DBHelper.assert)(ver !== this._current);

    if (this._current) {
      this._current.unref();
    }

    this._current = ver;
    ver.ref(); // Append to linked list

    ver.prev = this._dummyVersions.prev;
    ver.next = this._dummyVersions;
    ver.prev.next = ver;
    ver.next.prev = ver;
  } // TODO


  reuseManifest() {
    return false;
  }
  /**
   * dump current to manifest
   */


  writeSnapshot(writer) {
    const edit = new _VersionEdit.default(); // Save metadata

    edit.comparator = this.internalKeyComparator.userComparator.getName(); // Save compaction pointers

    for (let level = 0; level < _Format.Config.kNumLevels; level++) {
      if (!!this.compactPointers[level] && this.compactPointers[level].length !== 0) {
        const key = new _Format.InternalKey();
        key.decodeFrom(this.compactPointers[level]);
        edit.setCompactPointer(level, key);
      }
    } // Save files


    for (let level = 0; level < _Format.Config.kNumLevels; level++) {
      const files = this._current.files[level];

      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        edit.addFile(level, f.number, f.fileSize, f.smallest, f.largest);
      }
    }

    const record = _VersionEditRecord.default.add(edit);

    const status = new _Status.default(writer.addRecord(record));
    return status;
  }

  async writeCurrentFile(dbpath, manifestFileNumber) {
    const currentFilename = (0, _Filename.getCurrentFilename)(dbpath);
    let manifestFilename = (0, _Filename.getManifestFilename)(dbpath, manifestFileNumber);
    (0, _DBHelper.assert)(manifestFilename.startsWith(dbpath + "/"));
    manifestFilename = manifestFilename.substr(dbpath.length + 1);
    await this._options.env.writeFile(currentFilename, manifestFilename + "\n");
  }

  pickCompaction() {
    // We prefer compactions triggered by too much data in a level over
    // the compactions triggered by seeks.
    const shouldSizeCompaction = this._current.compactionScore >= 1;
    const shouldSeekCompaction = !!this._current.fileToCompact;
    let c;
    let level;

    if (shouldSizeCompaction) {
      level = this._current.compactionLevel;
      (0, _DBHelper.assert)(level >= 0);
      (0, _DBHelper.assert)(level + 1 < _Format.Config.kNumLevels);
      c = new _Compaction.default(this._options, level);

      for (const f of this._current.files[level]) {
        if (!this.compactPointers[level] || this.compactPointers[level].length === 0 || this.internalKeyComparator.compare(f.largest, this.compactPointers[level]) > 0) {
          c.inputs[0].push(f);
          break;
        }
      }

      if (c.inputs[0].length === 0) {
        c.inputs[0].push(this._current.files[level][0]);
      }
    } else if (shouldSeekCompaction) {
      level = this._current.fileToCompactLevel;
      c = new _Compaction.default(this._options, level);
      c.inputs[0].push(this._current.fileToCompact);
    } else {
      return;
    }

    c.inputVersion = this.current;
    c.inputVersion.ref();

    if (level === 0) {
      const smallest = new _Format.InternalKey();
      const largest = new _Format.InternalKey();
      this.getRange(c.inputs[0], smallest, largest); // Note that the next call will discard the file we placed in
      // c->inputs_[0] earlier and replace it with an overlapping set
      // which will include the picked file.

      c.inputs[0] = this._current.getOverlappingInputs(0, smallest, largest);
      (0, _DBHelper.assert)(c.inputs[0].length > 0);
    }

    this.setupOtherInputs(c);
    return c;
  }
  /**
   * Stores the minimal range that covers all entries in inputs in
   * smallest, *largest.
   * REQUIRES: inputs is not empty
   */


  getRange(inputs, smallest, largest) {
    (0, _DBHelper.assert)(inputs.length > 0);
    smallest.clear();
    largest.clear();

    for (let i = 0; i < inputs.length; i++) {
      const fileMetaData = inputs[i];

      if (i === 0) {
        smallest.buffer = fileMetaData.smallest.buffer;
        largest.buffer = fileMetaData.largest.buffer;
      } else {
        if (this.internalKeyComparator.compare(fileMetaData.smallest, smallest) < 0) {
          smallest.buffer = fileMetaData.smallest.buffer;
        }

        if (this.internalKeyComparator.compare(fileMetaData.largest, largest) > 0) {
          largest.buffer = fileMetaData.largest.buffer;
        }
      }
    }
  }
  /**
   * Stores the minimal range that covers all entries in inputs1 and inputs2
   * in *smallest, *largest.
   * REQUIRES: inputs is not empty
   */


  getRange2(inputs1, inputs2, smallest, largest) {
    const all = inputs1.concat(inputs2);
    this.getRange(all, smallest, largest);
  } // Finds the largest key in a vector of files. Returns true if files it not
  // empty.


  findLargestKey(icmp, files, largestKey) {
    if (files.length === 0) return false;
    largestKey.buffer = files[0].largest.buffer;

    for (let i = 0; i < files.length; i++) {
      const f = files[i];

      if (icmp.compare(f.largest, largestKey) > 0) {
        largestKey.buffer = f.largest.buffer;
      }
    }

    return true;
  } // Extracts the largest file b1 from |compaction_files| and then searches for a
  // b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a
  // file b2 (known as a boundary file) it adds it to |compaction_files| and then
  // searches again using this new upper bound.
  //
  // If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and
  // user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a
  // subsequent get operation will yield an incorrect result because it will
  // return the record from b2 in level i rather than from b1 because it searches
  // level by level for records matching the supplied user key.
  //
  // parameters:
  //   in     level_files:      List of files to search for boundary files.
  //   in/out compaction_files: List of files to extend by adding boundary files.


  addBoundaryInputs(icmp, levelFiles, compactionFiles) {
    let largestKey = new _Format.InternalKey();

    if (!this.findLargestKey(icmp, compactionFiles, largestKey)) {
      return;
    }

    while (true) {
      const smallestBoundaryFile = this.findSmallestBoundaryFile(icmp, levelFiles, largestKey);
      if (!smallestBoundaryFile) break;
      largestKey = smallestBoundaryFile.largest;
      compactionFiles.push(smallestBoundaryFile);
    }
  } // Finds minimum file b2=(l2, u2) in level file for which l2 > u1 and
  // user_key(l2) = user_key(u1)


  findSmallestBoundaryFile(icmp, levelFiles, largestKey) {
    const userComparator = icmp.userComparator;
    let smallestBoundaryFile;

    for (let i = 0; i < levelFiles.length; i++) {
      const f = levelFiles[i];

      if (icmp.compare(f.smallest, largestKey) > 0 && userComparator.compare(f.smallest.userKey, largestKey.userKey) === 0) {
        if (!smallestBoundaryFile || icmp.compare(f.smallest, smallestBoundaryFile.smallest) < 0) {
          smallestBoundaryFile = f;
        }
      }
    }

    return smallestBoundaryFile;
  }

  setupOtherInputs(c) {
    const level = c.level;
    let smallest = new _Format.InternalKey();
    let largest = new _Format.InternalKey();
    this.addBoundaryInputs(this.internalKeyComparator, this._current.files[level], c.inputs[0]);
    this.getRange(c.inputs[0], smallest, largest);
    c.inputs[1] = this.current.getOverlappingInputs(level + 1, smallest, largest);
    const allStart = new _Format.InternalKey();
    const allLimit = new _Format.InternalKey();
    this.getRange2(c.inputs[0], c.inputs[1], allStart, allLimit);

    if (c.inputs.length > 0) {
      const expand0 = this.current.getOverlappingInputs(level, allStart, allLimit);
      this.addBoundaryInputs(this.internalKeyComparator, this._current.files[level], expand0);
      const input0Size = this.getTotalBytes(c.inputs[0]);
      const input1Size = this.getTotalBytes(c.inputs[1]);
      const expand0Size = this.getTotalBytes(expand0);

      if (expand0.length > c.inputs[0].length && input1Size + expand0Size < (0, _VersionFormat.getExpandedCompactionByteSizeLimit)(this._options)) {
        const newStart = new _Format.InternalKey();
        const newLimit = new _Format.InternalKey();
        this.getRange(expand0, newStart, newLimit);

        const expand1 = this._current.getOverlappingInputs(level + 1, newStart, newLimit);

        if (expand1.length === c.inputs[1].length) {
          this._options.log(`Expanding@${level} ${c.inputs[0].length}+${c.inputs[1].length}` + ` (${input0Size}+${input1Size} bytes) to ${expand0Size}` + `+${expand1.length} (${expand0Size}+${input1Size} bytes)`);

          smallest = newStart;
          largest = newLimit;
          c.inputs[0] = expand0;
          c.inputs[1] = expand1;
          this.getRange2(c.inputs[0], c.inputs[1], allStart, allLimit);
        }
      }
    } // Compute the set of grandparent files that overlap this compaction
    // (parent == level+1; grandparent == level+2)


    if (level + 2 < _Format.Config.kNumLevels) {
      c.grandparents = this._current.getOverlappingInputs(level + 2, allStart, allLimit);
    } // Update the place where we will do the next compaction for this level.
    // We update this immediately instead of waiting for the VersionEdit
    // to be applied so that if the compaction fails, we will try a different
    // key range next time.


    this.compactPointers[level] = new _Slice.default(largest.buffer);
    c.edit.compactPointers.push({
      level,
      internalKey: largest
    });
  }

  addLiveFiles(live) {
    for (let ver = this._dummyVersions.next; ver != this._dummyVersions; ver = ver.next) {
      for (let level = 0; level < _Format.Config.kNumLevels; level++) {
        const files = ver.files[level];

        for (let i = 0; i < files.length; i++) {
          live.add(files[i].number);
        }
      }
    }
  } // Create an iterator that reads over the compaction
  // inputs(which includes 2 levels) for "currentCompaction".


  async *makeInputIterator(currentCompaction) {
    let num = 0;
    const options = {}; // Level-0 files have to be merged together.  For other levels,
    // we will make a concatenating iterator per level.
    // TODO(opt): use concatenating iterator for level-0 if there is no overlap

    const space = currentCompaction.level === 0 ? currentCompaction.inputs[0].length + 1 : 2;
    const list = Array.from({
      length: space
    });

    for (let which = 0; which < 2; which++) {
      if (currentCompaction.inputs[which].length > 0) {
        if (currentCompaction.level + which === 0) {
          // currentCompaction.level === 0 && which === 0
          const files = currentCompaction.inputs[which];

          for (let i = 0; i < files.length; i++) {
            list[num++] = this.tableCache.entryIterator(options, files[i].number, files[i].fileSize);
          }
        } else {
          // Create concatenating iterator for the files from this level
          const files = currentCompaction.inputs[which];
          list[num++] = this.levelFileEntryIterator(files);
        }
      }
    }

    (0, _DBHelper.assert)(num <= space);
    const merger = new _Merger.default(this.internalKeyComparator, list, num);
    yield* merger.iterator();
  }

  async *levelFileEntryIterator(files) {
    const options = {};

    for (const fileEntry of _Version.default.levelFileNumIterator(this.internalKeyComparator, files)) {
      const fileNumber = (0, _Coding.decodeFixed64)(fileEntry.value.buffer.slice(0, 8));
      const fileSize = (0, _Coding.decodeFixed64)(fileEntry.value.buffer.slice(8));
      yield* this.tableCache.entryIterator(options, Number(fileNumber), Number(fileSize));
    }
  }

}

exports.default = VersionSet;
//# sourceMappingURL=VersionSet.js.map