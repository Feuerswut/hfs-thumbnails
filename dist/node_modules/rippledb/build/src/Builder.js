"use strict";

exports.__esModule = true;
exports.buildTable = buildTable;

var _Status = _interopRequireDefault(require("./Status"));

var _Filename = require("./Filename");

var _SSTableBuilder = _interopRequireDefault(require("./SSTableBuilder"));

var _Format = require("./Format");

var _console = require("console");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2018-present, heineiuo.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
async function buildTable(dbpath, env, options, iterator, meta) {
  options.log(`Level-0 table #${meta.number}: started`);
  const tableFilename = (0, _Filename.getTableFilename)(dbpath, meta.number);
  let status = new _Status.default(env.open(tableFilename, "a+"));

  if (!(await status.ok())) {
    return status;
  }

  const builder = new _SSTableBuilder.default(options, await status.promise);
  let hasSmallestSet = false;

  for (const entry of iterator) {
    if (!hasSmallestSet) {
      meta.smallest = _Format.InternalKey.from(entry.key);
      hasSmallestSet = true;
    }

    meta.largest.decodeFrom(entry.key);
    await builder.add(entry.key, entry.value);
  }

  status = new _Status.default(builder.finish());

  if (!(await status.ok())) {
    return status;
  }

  meta.fileSize = builder.fileSize;
  (0, _console.assert)(meta.fileSize > 0);
  options.log(`Level-0 table #${meta.number}: ${meta.fileSize} bytes ${(await status.ok()) ? "status ok" : "status error"}`); // TODO check if table has errors

  return status;
}
//# sourceMappingURL=Builder.js.map