"use strict";

exports.__esModule = true;
exports.default = void 0;

var _Coding = require("./Coding");

var _Format = require("./Format");

var _Slice = _interopRequireDefault(require("./Slice"));

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SSTableBlock {
  constructor(contents) {
    _defineProperty(this, "blockType", void 0);

    _defineProperty(this, "_restartPoint", void 0);

    _defineProperty(this, "_size", void 0);

    _defineProperty(this, "_buffer", void 0);

    this._buffer = contents.data.buffer;
    this._size = contents.data.size;
    const maxRestartsAllowed = (this._size - _Format.kSizeOfUInt32) / _Format.kSizeOfUInt32;

    if (this.getNumRestarts() > maxRestartsAllowed) {
      // The size is too small for NumRestarts()
      this._size = 0;
    } else {
      this._restartPoint = this._size - (1 + this.getNumRestarts()) * _Format.kSizeOfUInt32;
    }
  }

  get buffer() {
    return this._buffer;
  }

  get size() {
    return this._size;
  }

  getNumRestarts() {
    return (0, _Coding.decodeFixed32)(this._buffer.slice(this._size - 4));
  }

  decodeEntry(offset, lastKey) {
    const shared = (0, _Coding.decodeFixed32)(this._buffer.slice(offset, offset + _Format.kSizeOfUInt32));
    const nonShared = (0, _Coding.decodeFixed32)(this._buffer.slice(offset + _Format.kSizeOfUInt32, offset + 8));
    const valueLength = (0, _Coding.decodeFixed32)(this._buffer.slice(offset + 8, offset + 12));
    const keyLength = shared + nonShared;

    const nonSharedKey = this._buffer.slice(offset + 12, offset + 12 + nonShared);

    const sharedKey = lastKey.buffer.slice(0, shared);
    const key = new _Slice.default(_Buffer.Buffer.concat([sharedKey, nonSharedKey]));
    (0, _DBHelper.assert)(key.length === keyLength);
    return {
      rawSize: 12 + nonShared + valueLength,
      shared,
      nonShared,
      entry: {
        key,
        value: new _Slice.default(this._buffer.slice(offset + 12 + nonShared, offset + 12 + nonShared + valueLength))
      }
    };
  }

  *restartPointIterator(reverse = false) {
    if (reverse) {
      let currentOffset = this.size - 4;

      while (true) {
        if (currentOffset <= this._restartPoint) break;
        yield (0, _Coding.decodeFixed32)(this._buffer.slice(currentOffset - _Format.kSizeOfUInt32, currentOffset));
        currentOffset -= _Format.kSizeOfUInt32;
      }
    } else {
      let currentOffset = this._restartPoint;

      while (true) {
        if (currentOffset >= this._size - _Format.kSizeOfUInt32) {
          break;
        }

        yield (0, _Coding.decodeFixed32)(this._buffer.slice(currentOffset, currentOffset + _Format.kSizeOfUInt32));
        currentOffset += _Format.kSizeOfUInt32;
      }
    }
  }

  *iterator(comparator, reverse = false) {
    const numRestarts = this.getNumRestarts();

    if (numRestarts === 0) {
      return;
    }

    if (reverse) {
      const restartPointIterator = this.restartPointIterator(reverse);
      let rightEdge = this._restartPoint;
      let point = restartPointIterator.next();
      let offset = point.value;
      let lastKey = new _Slice.default();
      let cache = [];

      while (true) {
        const currentRestartedEntry = this.decodeEntry(offset, lastKey);
        cache.unshift(currentRestartedEntry.entry);
        lastKey = new _Slice.default(currentRestartedEntry.entry.key);
        offset += currentRestartedEntry.rawSize;

        if (offset === rightEdge) {
          yield* cache;
          rightEdge = point.value;
          point = restartPointIterator.next();

          if (!point || !point.value) {
            break;
          }

          offset = point.value;
          lastKey = new _Slice.default();
          cache = [];
        }
      }
    } else {
      const restartPointIterator = this.restartPointIterator(reverse);
      let restartPointIteratorResult = restartPointIterator.next();
      let currentRestartPoint = restartPointIteratorResult.value;
      let offset = 0;
      let lastKey = new _Slice.default();

      while (true) {
        if (offset >= this._restartPoint) break;
        const currentRestartedEntry = this.decodeEntry(offset, lastKey);
        yield currentRestartedEntry.entry;
        lastKey = new _Slice.default(currentRestartedEntry.entry.key);
        offset += currentRestartedEntry.rawSize;

        if (offset === currentRestartPoint) {
          lastKey = new _Slice.default();
          restartPointIteratorResult = restartPointIterator.next();
          currentRestartPoint = restartPointIteratorResult.value;
        }
      }
    }
  }

}

exports.default = SSTableBlock;
//# sourceMappingURL=SSTableBlock.js.map