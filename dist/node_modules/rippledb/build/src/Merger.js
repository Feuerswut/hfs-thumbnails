"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class IteratorMerger {
  constructor(icmp, list, num) {
    _defineProperty(this, "_icmp", void 0);

    _defineProperty(this, "_list", void 0);

    _defineProperty(this, "_num", void 0);

    _defineProperty(this, "_cache", void 0);

    this._icmp = icmp;
    this._list = list;
    this._num = num;
    this._cache = new Array(num);
  }

  async *iterator(reverse = false) {
    (0, _DBHelper.assert)(this._num >= 0);

    if (this._num === 0) {
      return;
    }

    if (this._num === 1) {
      yield* this._list[0];
      return;
    }

    while (true) {
      const current = reverse ? await this.findLargest() : await this.findSmallest();
      if (!current) break;
      yield current;
    }
  }

  async findLargest() {
    let largest = null;
    let hit = -1;

    for (let i = 0; i < this._num; i++) {
      const child = this._cache[i] || (await this._list[i].next());
      this._cache[i] = child;

      if (!child.done) {
        if (largest === null) {
          largest = child.value;
          hit = i;
        } else if (this._icmp.compare(child.value.key, largest.key) > 0) {
          largest = child.value;
          hit = i;
        }
      }
    }

    for (let i = 0; i < this._num; i++) {
      if (i === hit) {
        this._cache[i] = null;
      }
    }

    return largest;
  }

  async findSmallest() {
    let smallest = null;
    let hit = -1;

    for (let i = 0; i < this._num; i++) {
      const child = this._cache[i] || (await this._list[i].next());
      this._cache[i] = child;

      if (!child.done) {
        if (smallest === null) {
          smallest = child.value;
          hit = i;
        } else if (this._icmp.compare(child.value.key, smallest.key) < 0) {
          smallest = child.value;
          hit = i;
        }
      }
    }

    for (let i = 0; i < this._num; i++) {
      if (i === hit) {
        this._cache[i] = null;
      }
    }

    return smallest;
  }

}

exports.default = IteratorMerger;
//# sourceMappingURL=Merger.js.map