"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

var _Slice = _interopRequireDefault(require("./Slice"));

var _VersionFormat = require("./VersionFormat");

var _Format = require("./Format");

var _Compaction = _interopRequireDefault(require("./Compaction"));

var _Status = _interopRequireDefault(require("./Status"));

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SaverState;

(function (SaverState) {
  SaverState[SaverState["kNotFound"] = 0] = "kNotFound";
  SaverState[SaverState["kFound"] = 1] = "kFound";
  SaverState[SaverState["kDeleted"] = 2] = "kDeleted";
  SaverState[SaverState["kCorrupt"] = 3] = "kCorrupt";
})(SaverState || (SaverState = {}));

class Saver {
  constructor() {
    _defineProperty(this, "state", void 0);

    _defineProperty(this, "ucmp", void 0);

    _defineProperty(this, "userKey", void 0);

    _defineProperty(this, "value", void 0);
  }

}

class State {
  constructor() {
    _defineProperty(this, "s", void 0);

    _defineProperty(this, "vset", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "ikey", void 0);

    _defineProperty(this, "lastFileRead", void 0);

    _defineProperty(this, "lastFileReadLevel", void 0);

    _defineProperty(this, "stats", void 0);

    _defineProperty(this, "found", void 0);

    _defineProperty(this, "saver", new Saver());
  }

  static async match(state, level, f) {
    if (!(state instanceof State)) return Promise.resolve(false);

    if (!state.stats.seekFile && !!state.lastFileRead) {
      // We have had more than one seek for this read.  Charge the 1st file.
      state.stats.seekFile = state.lastFileRead;
      state.stats.seekFileLevel = state.lastFileReadLevel;
    }

    state.lastFileRead = f;
    state.lastFileReadLevel = level;
    state.s = await state.vset.tableCache.get(state.options, f.number, f.fileSize, state.ikey, state.saver, Version.saveValue // eslint-disable-line
    );

    if (!(await state.s.ok())) {
      if (!state.s.isNotFound()) {
        // table.get return Status.createNotFound
        return false;
      } else {
        state.s = new _Status.default();
      }
    }

    switch (state.saver.state) {
      case SaverState.kNotFound:
        return true;
      // Keep searching in other files

      case SaverState.kFound:
        state.found = true;
        return false;

      case SaverState.kDeleted:
        return false;

      case SaverState.kCorrupt:
        state.s = _Status.default.createCorruption(`corrupted key for ${state.saver.userKey.toString()}`);
        state.found = true;
        return false;
    }

    return false;
  }

}

class Version {
  static saveValue(saver, ikey, v) {
    if (!(saver instanceof Saver)) return;
    const parsedKey = new _Format.ParsedInternalKey(); // saver.state default value is kNotFound

    if (!(0, _Format.parseInternalKey)(ikey, parsedKey)) {
      saver.state = SaverState.kCorrupt;
    } else {
      if (saver.ucmp.compare(parsedKey.userKey, saver.userKey) == 0) {
        saver.state = parsedKey.valueType == _Format.ValueType.kTypeValue ? SaverState.kFound : SaverState.kDeleted;

        if (saver.state == SaverState.kFound) {
          saver.value = _Buffer.Buffer.concat([v.buffer]);
        }
      }
    }
  } // An internal iterator.  For a given version/level pair, yields
  // information about the files in the level.  For a given entry, key()
  // is the largest key that occurs in the file, and value() is an
  // 16-byte value containing the file number and file size, both
  // encoded using EncodeFixed64.


  static *levelFileNumIterator(icmp, // TODO used for seek
  files) {
    for (const file of files) {
      const valueBuf = _Buffer.Buffer.alloc(16);

      valueBuf.fillBuffer((0, _Coding.encodeFixed64)(file.number), 0, 8);
      valueBuf.fillBuffer((0, _Coding.encodeFixed64)(file.fileSize), 8, 16);
      yield {
        key: file.largest,
        value: new _Slice.default(valueBuf)
      };
    }
  }

  static afterFile(ucmp, userKey, f) {
    return !!userKey && ucmp.compare(userKey, f.largest.userKey) > 0;
  }

  static beforeFile(ucmp, userKey, f) {
    return !!userKey && ucmp.compare(userKey, f.smallest.userKey) < 0;
  }

  constructor(versionSet) {
    _defineProperty(this, "versionSet", void 0);

    _defineProperty(this, "next", void 0);

    _defineProperty(this, "prev", void 0);

    _defineProperty(this, "refs", void 0);

    _defineProperty(this, "fileToCompact", void 0);

    _defineProperty(this, "fileToCompactLevel", void 0);

    _defineProperty(this, "compactionScore", void 0);

    _defineProperty(this, "compactionLevel", void 0);

    _defineProperty(this, "files", void 0);

    this.versionSet = versionSet;
    this.next = this;
    this.prev = this;
    this.refs = 0;
    this.fileToCompactLevel = -1;
    this.compactionScore = -1;
    this.compactionLevel = -1;
    const cmp = new _VersionFormat.BySmallestKey(versionSet.internalKeyComparator);
    this.files = Array.from({
      length: _Format.Config.kNumLevels
    }, () => []);
  }

  ref() {
    this.refs++;
  }

  unref() {
    (0, _DBHelper.assert)(this.refs >= 1);
    this.refs--;

    if (this.refs === 0) {// TODO delete
    }
  }

  async get(lkey, stats) {
    delete stats.seekFile;
    stats.seekFileLevel = -1;
    const state = new State();
    state.found = false;
    state.stats = stats;
    state.lastFileReadLevel = -1;
    state.options = {};
    state.ikey = lkey.internalKey;
    state.vset = this.versionSet;
    state.saver.state = SaverState.kNotFound;
    state.saver.ucmp = this.versionSet.internalKeyComparator.userComparator;
    state.saver.userKey = lkey.userKey;
    await this.forEachOverlapping(lkey.userKey, lkey.internalKey, state, State.match);

    if (!state.found) {
      return _Status.default.createNotFound();
    }

    return new _Status.default(Promise.resolve(state.saver.value));
  } // Call match() for every file that overlaps userKey in
  // order from newest to oldest.  If an invocation of func returns
  // false, makes no more calls.
  //
  // REQUIRES: user portion of internal_key == user_key.
  // match means 'continue searching'


  async forEachOverlapping(userKey, internalKey, arg, match) {
    const ucmp = this.versionSet.internalKeyComparator.userComparator; // Search level-0 in order from newest to oldest.

    const tmp = [];

    for (let i = 0; i < this.files[0].length; i++) {
      const f = this.files[0][i];

      if (ucmp.compare(userKey, f.smallest.userKey) >= 0 && ucmp.compare(userKey, f.largest.userKey) <= 0) {
        tmp.push(f);
      }
    }

    if (tmp.length > 0) {
      // NewestFirst
      tmp.sort((a, b) => a.number > b.number ? -1 : 1);

      for (let i = 0; i < tmp.length; i++) {
        if (!(await match(arg, 0, tmp[i]))) {
          return;
        }
      }
    } // Search other levels.


    for (let level = 0; level < _Format.Config.kNumLevels; level++) {
      const numFiles = this.files[level].length;
      if (numFiles === 0) continue;
      const index = this.findFile(this.versionSet.internalKeyComparator, this.files[level], internalKey);

      if (index < numFiles) {
        const f = this.files[level][index];

        if (ucmp.compare(userKey, f.smallest.userKey) < 0) {// All of "f" is past any data for user_key
        } else {
          if (!(await match(arg, level, f))) {
            return;
          }
        }
      }
    }
  }

  someFileOverlapsRange(icmp, disjointSortedFile, files, smallestUserKey, largestUserKey) {
    const ucmp = icmp.userComparator;

    if (!disjointSortedFile) {
      // Need to check against all files
      for (let i = 0; i < files.length; i++) {
        const f = files[i];

        if (Version.afterFile(ucmp, smallestUserKey, f) || Version.beforeFile(ucmp, largestUserKey, f)) {// No overlap
        } else {
          return true;
        }
      }

      return false;
    } // Binary search over file list


    let index = 0;

    if (!!smallestUserKey) {
      // Find the earliest possible internal key for smallest_user_key
      const smallkey = new _Format.InternalKey(smallestUserKey, _Format.InternalKey.kMaxSequenceNumber, _Format.kValueTypeForSeek);
      index = this.findFile(icmp, files, smallkey);
    }

    if (index >= files.length) {
      return false;
    }

    return !Version.beforeFile(ucmp, largestUserKey, files[index]);
  } // binary search


  findFile(icmp, files, key) {
    let left = 0; //  uint32_t

    let right = files.length; // uint32_t

    while (left < right) {
      const mid = Math.floor((left + right) / 2);
      const file = files[mid];

      if (icmp.compare(file.largest, key) < 0) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    return right;
  }

  overlapInLevel(level, smallestUserKey, largestUserKey) {
    return this.someFileOverlapsRange(this.versionSet.internalKeyComparator, level > 0, this.files[level], smallestUserKey, largestUserKey);
  } // Store in "*inputs" all files in "level" that overlap [begin,end]


  getOverlappingInputs(level, begin, end) {
    (0, _DBHelper.assert)(level >= 0);
    (0, _DBHelper.assert)(level < _Format.Config.kNumLevels);
    let inputs = [];
    let userBegin = begin ? begin.userKey : new _Slice.default();
    let userEnd = end ? end.userKey : new _Slice.default();
    const userComparator = this.versionSet.internalKeyComparator.userComparator;

    for (let i = 0; i < this.files[level].length;) {
      const fileMetaData = this.files[level][i++];
      const fileStart = fileMetaData.smallest.userKey;
      const fileLimit = fileMetaData.largest.userKey;

      if (!!begin && userComparator.compare(fileLimit, userBegin) < 0) {// "f" is completely before specified range; skip it
      } else if (!!end && userComparator.compare(fileStart, userEnd) > 0) {// "f" is completely after specified range; skip it
      } else {
        inputs.push(fileMetaData);

        if (level === 0) {
          if (!!begin && userComparator.compare(fileStart, userBegin) < 0) {
            userBegin = fileStart;
            inputs = [];
            i = 0;
          } else if (!!end && userComparator.compare(fileLimit, userEnd) > 0) {
            userEnd = fileLimit;
            inputs = [];
            i = 0;
          }
        }
      }
    }

    return inputs;
  }

  pickLevelForMemTableOutput(minUserKey, maxUserKey) {
    let level = 0;

    if (!this.overlapInLevel(0, minUserKey, maxUserKey)) {
      // Push to next level if there is no overlap in next level,
      // and the #bytes overlapping in the level after that are limited.
      const start = new _Format.InternalKey(minUserKey, _Format.InternalKey.kMaxSequenceNumber, _Format.kValueTypeForSeek);
      const limit = new _Format.InternalKey(maxUserKey, 0n, _Format.ValueType.kTypeValue);
      let overlaps = [];

      while (level < _Format.Config.kMaxMemCompactLevel) {
        if (this.overlapInLevel(level + 1, minUserKey, maxUserKey)) {
          break;
        }

        if (level + 2 < _Format.Config.kNumLevels) {
          // Check that file does not overlap too many grandparent bytes.
          overlaps = this.getOverlappingInputs(level + 2, start, limit);

          const sum = _Compaction.default.totalFileSize(overlaps);

          if (sum > _Compaction.default.maxGrandParentOverlapBytes(this.versionSet._options)) {
            break;
          }
        }

        level++;
      }
    }

    return level;
  }

  updateStats(stats) {
    // TODO
    return false;
  }

}

exports.default = Version;
//# sourceMappingURL=Version.js.map