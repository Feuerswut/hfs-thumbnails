"use strict";

exports.__esModule = true;
exports.encodeFixed64 = encodeFixed64;
exports.decodeFixed64 = decodeFixed64;
exports.encodeFixed32 = encodeFixed32;
exports.decodeFixed32 = decodeFixed32;
exports.getLengthPrefixedSlice = getLengthPrefixedSlice;

var _Buffer = require("./Buffer");

var _DBHelper = require("./DBHelper");

var _Slice = _interopRequireDefault(require("./Slice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2018-present, heineiuo.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const kFixed64MaxValue = (1n << 56n) - 1n; // only use 1 - 7 bytes

function encodeFixed64(value) {
  // or Buffer.from(new BigUint64Array([BigInt(value)]).buffer)
  const buf = _Buffer.Buffer.alloc(8);

  const bigIntValue = BigInt(value);
  buf.writeBigUInt64LE(bigIntValue < kFixed64MaxValue ? bigIntValue : kFixed64MaxValue);
  return buf;
}

function decodeFixed64(buf) {
  // or BigInt(new BigUint64Array(bufferToArrayBuffer(buf)).toString())
  return buf.readBigUInt64LE();
}

function encodeFixed32(value) {
  const buf = _Buffer.Buffer.alloc(4);

  buf.writeUInt32LE(value, 0);
  return buf;
}

function decodeFixed32(buf) {
  (0, _DBHelper.assert)(buf.length >= 4);
  return buf.readUInt32LE(0);
} // function bufferToArrayBuffer(buf: Buffer) {
//   let ab = new ArrayBuffer(buf.length)
//   let view = new Uint8Array(ab)
//   for (let i = 0; i < buf.length; ++i) {
//     view[i] = buf[i]
//   }
//   return ab
// }


function getLengthPrefixedSlice(key) {
  const internalKeySize = _DBHelper.varint.decode(key.buffer);

  const internalKeyBuffer = key.buffer.slice(_DBHelper.varint.decode.bytes, _DBHelper.varint.decode.bytes + internalKeySize);
  return new _Slice.default(internalKeyBuffer);
}
//# sourceMappingURL=Coding.js.map