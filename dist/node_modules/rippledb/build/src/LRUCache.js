"use strict";

exports.__esModule = true;
exports.LRUCache = void 0;

var _Yallist = require("./Yallist");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");

const naiveLength = () => 1;

class Entry {
  constructor(key, value, length, now, maxAge) {
    _defineProperty(this, "key", void 0);

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "length", void 0);

    _defineProperty(this, "now", void 0);

    _defineProperty(this, "maxAge", void 0);

    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }

} // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


class LRUCache {
  constructor(options = {}) {
    _defineProperty(this, LENGTH, 0);

    _defineProperty(this, LENGTH_CALCULATOR, void 0);

    _defineProperty(this, MAX, void 0);

    _defineProperty(this, ALLOW_STALE, void 0);

    _defineProperty(this, MAX_AGE, void 0);

    _defineProperty(this, DISPOSE, void 0);

    _defineProperty(this, NO_DISPOSE_ON_SET, void 0);

    _defineProperty(this, UPDATE_AGE_ON_GET, void 0);

    _defineProperty(this, LRU_LIST, void 0);

    _defineProperty(this, CACHE, new Map());

    if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number"); // Kind of weird to have a default max of Infinity, but oh well.

    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }

  reset() {
    const dispose = this[DISPOSE];

    if (dispose) {
      if (this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(hit => dispose(hit.key, hit.value));
      }
    }

    this[CACHE] = new Map(); // hash of items by key

    this[LRU_LIST] = new _Yallist.Yallist(); // list of items in order of use recency

    this[LENGTH] = 0; // length of items in the list
  }

  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    const dispose = this[DISPOSE]; // ts cannot handle Map.has and Map.get.

    const entry = this[CACHE].get(key);

    if (entry) {
      if (len > this[MAX]) {
        this.del(entry);
        return false;
      }

      const node = this[CACHE].get(key); // @ts-ignore // ts cannot handle Map.has, Map.get

      const item = node.value; // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking

      if (dispose) {
        if (!this[NO_DISPOSE_ON_SET]) dispose(key, item.value);
      }

      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      this.trim();
      return true;
    }

    const hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

    if (hit.length > this[MAX]) {
      if (dispose) dispose(key, value);
      return false;
    }

    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    this.trim();
    return true;
  }

  del(node) {
    if (node) {
      const dispose = this[DISPOSE];
      const hit = node.value;
      if (dispose) dispose(hit.key, hit.value);
      this[LENGTH] -= hit.length;
      this[CACHE].delete(hit.key);
      this[LRU_LIST].removeNode(node);
    }
  }

  isStale(hit) {
    if (!hit || !hit.maxAge && !this[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;

    if (hit.maxAge) {
      return diff > hit.maxAge;
    }

    return diff > this[MAX_AGE];
  }

  trim() {
    if (this[LENGTH] > this[MAX]) {
      for (let walker = this[LRU_LIST].tail; this[LENGTH] > this[MAX] && walker !== null;) {
        // We know that we're about to delete this one, and also
        // what the next least recently used key will be, so just
        // go ahead and set it now.
        const prev = walker.prev;
        this.del(walker);
        walker = prev;
      }
    }
  }

  get(key, doUse = false) {
    const node = this[CACHE].get(key);

    if (node) {
      const hit = node.value;

      if (this.isStale(hit)) {
        this.del(node);
        if (!this[ALLOW_STALE]) return;
      } else {
        if (doUse) {
          if (this[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
          this[LRU_LIST].unshiftNode(node);
        }
      }

      return hit.value;
    }
  }

}

exports.LRUCache = LRUCache;
//# sourceMappingURL=LRUCache.js.map