"use strict";

exports.__esModule = true;
exports.getMaxBytesForLevel = getMaxBytesForLevel;
exports.getExpandedCompactionByteSizeLimit = getExpandedCompactionByteSizeLimit;
exports.FileSet = exports.BySmallestKey = exports.FileMetaData = void 0;

var _Format = require("./Format");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FileMetaData {
  // reference count
  // if seeks > allowedSeeks, trigger compaction
  constructor() {
    _defineProperty(this, "refs", void 0);

    _defineProperty(this, "allowedSeeks", void 0);

    _defineProperty(this, "fileSize", void 0);

    _defineProperty(this, "number", void 0);

    _defineProperty(this, "smallest", void 0);

    _defineProperty(this, "largest", void 0);

    this.refs = 0;
    this.allowedSeeks = 1 << 30;
    this.fileSize = 0;
    this.smallest = new _Format.InternalKey();
    this.largest = new _Format.InternalKey();
  }

}

exports.FileMetaData = FileMetaData;

class BySmallestKey {
  constructor(cmp) {
    _defineProperty(this, "internalComparator", void 0);

    if (cmp) this.internalComparator = cmp;
  } // if file1 < file2 then true


  operator(file1, file2) {
    const r = this.internalComparator.compare(file1.smallest, file2.smallest);
    if (r === 0) return file1.number < file2.number;
    return r < 0;
  }

} // sorted setï¼ˆcompared by internalkey comparator, if small key
// is equal then compare file number
// TODO not copy inserted value here, just reference, should copy?


exports.BySmallestKey = BySmallestKey;

class FileSet {
  constructor(cmp) {
    _defineProperty(this, "_set", void 0);

    _defineProperty(this, "compare", void 0);

    this.compare = cmp;
    this._set = [];
  }

  add(file) {
    if (this._set.find(item => item.number === file.number)) {
      return;
    }

    const setLength = this._set.length;

    if (setLength === 0) {
      this._set.push(file);
    } else {
      for (let i = 0; i < setLength; i++) {
        const file1 = this._set[i];
        const b = this.compare.operator(file, file1);

        if (b) {
          this._set.splice(i, 0, file);

          return;
        }
      }

      this._set.push(file);
    }
  } // push(file: FileMetaData): void {
  //   const endFile = this.end()
  //   assert(!endFile || this.compare.operator(endFile, file))
  //   this._set.push(file)
  // }
  // begin(): FileMetaData {
  //   return this._set[0]
  // }
  // end(): FileMetaData | null {
  //   return this._set[this._set.length - 1] || null
  // }
  // delete(file: FileMetaData): void {
  //   this._set = this._set.filter(item => item !== file)
  // }
  // size(): number {
  //   return this._set.length
  // }
  // totalBytes(): number {
  //   let bytes = 0
  //   for (const fileMetaData of this.iterator()) {
  //     bytes += fileMetaData.fileSize
  //   }
  //   return bytes
  // }
  // get data(): FileMetaData[] {
  //   return this._set
  // }


  *iterator() {
    const setLength = this._set.length;

    for (let i = 0; i < setLength; i++) {
      yield this._set[i];
    }
  }

}

exports.FileSet = FileSet;

function getMaxBytesForLevel(level) {
  // Note: the result for level zero is not really used since we set
  // the level-0 compaction threshold based on number of files.
  // Result for both level-0 and level-1
  let result = 10.0 * 1048576.0;

  while (level > 1) {
    result *= 10;
    level--;
  }

  return result;
}

function getExpandedCompactionByteSizeLimit(options) {
  return 25 * options.maxFileSize;
}
//# sourceMappingURL=VersionFormat.js.map