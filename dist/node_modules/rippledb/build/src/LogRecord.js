"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Slice = _interopRequireDefault(require("./Slice"));

var _Format = require("./Format");

var _Buffer = require("./Buffer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2018-present, heineiuo.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class LogRecord {
  static add(key, value) {
    return new _Slice.default(_Buffer.Buffer.concat([_Buffer.Buffer.fromUnknown([_Format.ValueType.kTypeValue]), _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(key.length)), key.buffer, _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(value.length)), value.buffer]));
  }

  static del(key) {
    return new _Slice.default(_Buffer.Buffer.concat([_Buffer.Buffer.fromUnknown([_Format.ValueType.kTypeDeletion]), _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(key.length)), key.buffer]));
  } // static decode(op: Slice): { type: ValueType; key: Slice; value?: Slice } {
  //   const valueType = op.buffer.readUInt8(0)
  //   let index = 1
  //   const keyLength = varint.decode(op.buffer.slice(1))
  //   index += varint.decode.bytes
  //   const keyBuffer = op.buffer.slice(index, index + keyLength)
  //   index += keyLength
  //   if (valueType === ValueType.kTypeDeletion) {
  //     return {
  //       type: valueType,
  //       key: new Slice(keyBuffer),
  //     }
  //   }
  //   const valueLength = varint.decode(op.buffer.slice(index))
  //   index += varint.decode.bytes
  //   const valueBuffer = op.buffer.slice(index, index + valueLength)
  //   return {
  //     type: valueType,
  //     key: new Slice(keyBuffer),
  //     value: new Slice(valueBuffer),
  //   }
  // }
  // constructor(recordType: RecordType, data: Slice | Buffer) {
  //   this.recordType = recordType
  //   this.data = new Slice(data)
  // }
  // get length(): number {
  //   return this.data.length + kHeaderSize
  // }
  // get size(): number {
  //   return this.length
  // }
  // data: Slice
  // recordType: RecordType
  // get buffer(): Buffer {
  //   const lengthBuf = Buffer.from(
  //     createHexStringFromDecimal(this.data.length),
  //     'hex'
  //   )
  //   const typeBuf = Buffer.from([this.recordType])
  //   const sum = crc32(Buffer.concat([typeBuf, this.data.buffer]))
  //   return Buffer.concat([sum, lengthBuf, typeBuf, this.data.buffer])
  // }


}

exports.default = LogRecord;
//# sourceMappingURL=LogRecord.js.map