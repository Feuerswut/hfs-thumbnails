"use strict";

exports.__esModule = true;
exports.default = void 0;

var _Crc = require("./Crc32");

var _Buffer = require("./Buffer");

var _DBHelper = require("./DBHelper");

var _Slice = _interopRequireDefault(require("./Slice"));

var _BloomFilter = _interopRequireDefault(require("./BloomFilter"));

var _SSTableFooter = _interopRequireDefault(require("./SSTableFooter"));

var _Coding = require("./Coding");

var _Format = require("./Format");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SSTableBuilder {
  constructor(options, file) {
    _defineProperty(this, "_closed", void 0);

    _defineProperty(this, "_numberOfEntries", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_file", void 0);

    _defineProperty(this, "_fileSize", void 0);

    _defineProperty(this, "_lastKey", void 0);

    _defineProperty(this, "_dataBlock", void 0);

    _defineProperty(this, "_metaBlock", void 0);

    _defineProperty(this, "_indexBlock", void 0);

    _defineProperty(this, "_footer", void 0);

    _defineProperty(this, "_offset", void 0);

    _defineProperty(this, "_pendingIndexEntry", void 0);

    _defineProperty(this, "_pendingHandle", void 0);

    this._file = file;
    this._fileSize = 0;
    this._metaBlock = new FilterBlockBuilder(); // eslint-disable-line

    this._footer = new _SSTableFooter.default(_Buffer.Buffer.alloc(48));
    this._numberOfEntries = 0;
    this._offset = 0;
    this._pendingIndexEntry = false;
    this._closed = false;
    this._options = options;
    this._dataBlock = new BlockBuilder(this._options); // eslint-disable-line

    this._dataBlock.blockType = "datablock";
    this._indexBlock = new BlockBuilder(this._options); // eslint-disable-line

    this._indexBlock.blockType = "indexblock";
    this._pendingHandle = new _Format.BlockHandle();
  }

  // key is internal key
  async add(key, value) {
    (0, _DBHelper.assert)(!this._closed);

    if (this._numberOfEntries > 0) {
      (0, _DBHelper.assert)(this._options.comparator.compare(key, this._lastKey) > 0, `new key must bigger then last key`);
    }

    if (this._pendingIndexEntry) {
      (0, _DBHelper.assert)(this._dataBlock.isEmpty());

      this._options.comparator.findShortestSeparator(this._lastKey, key);

      const handleEncoding = this._pendingHandle.buffer;

      this._indexBlock.add(this._lastKey, new _Slice.default(handleEncoding));

      this._pendingIndexEntry = false;
    }

    if (!!this._metaBlock) {
      this._metaBlock.addkey(key);
    }

    this._lastKey = new _Slice.default(key);
    this._numberOfEntries++;

    this._dataBlock.add(key, value);

    if (this._dataBlock.currentSizeEstimate() > this._options.blockSize) {
      await this.flush();
    }
  }

  get numEntries() {
    return this._numberOfEntries;
  }

  get fileSize() {
    return this._fileSize;
  }

  async flush() {
    (0, _DBHelper.assert)(!this._closed);
    if (this._dataBlock.isEmpty()) return;
    (0, _DBHelper.assert)(!this._pendingIndexEntry);
    await this.writeBlock(this._dataBlock, this._pendingHandle);
    this._pendingIndexEntry = true;

    if (!!this._metaBlock) {
      this._metaBlock.startBlock(this._offset);
    }
  }

  async writeBlock(block, handle) {
    // File format contains a sequence of blocks where each block has:
    //    block_data: uint8[n]
    //    type: uint8
    //    crc: uint32
    const raw = block.finish();
    const type = _Format.CompressionTypes.none; // TODO

    await this.writeRawBlock(raw, type, handle);

    this._dataBlock.reset();
  }

  async writeRawBlock(blockContent, type, handle) {
    handle.offset = this._offset;
    handle.size = blockContent.size;
    await this.appendFile(blockContent.buffer);

    const trailer = _Buffer.Buffer.alloc(_Format.kBlockTrailerSize);

    trailer[0] = type;
    const crc32buffer = (0, _Crc.crc32)(_Buffer.Buffer.concat([blockContent.buffer, _Buffer.Buffer.fromUnknown([type])]));
    trailer.fillBuffer(crc32buffer, 1, 5);
    await this.appendFile(trailer);
    this._offset += blockContent.size + _Format.kBlockTrailerSize;
  }

  async appendFile(buffer) {
    await this._file.appendFile(buffer, {
      encoding: "buffer"
    });
    this._fileSize += buffer.length;
  }

  async close() {
    if (!this._closed) {
      const file = this._file;
      this._closed = true;
      delete this._file;

      try {
        await file.close();
      } catch (e) {}
    }
  }

  async abandon() {
    await this.close();
  }

  async finish() {
    await this.flush();
    const filterBlockHandle = new _Format.BlockHandle();
    const metaIndexBlockHandle = new _Format.BlockHandle();
    const indexBlockHandle = new _Format.BlockHandle();

    if (!!this._metaBlock) {
      await this.writeRawBlock(this._metaBlock.finish(), _Format.CompressionTypes.none, filterBlockHandle);
    } // eslint-disable-next-line


    const metaIndexBlock = new BlockBuilder(this._options);
    metaIndexBlock.blockType = "metaindexblock";

    if (!!this._metaBlock) {
      let key = "filter.";
      key += this._options.filterPolicy.name();
      const handleEncoding = filterBlockHandle.buffer;
      metaIndexBlock.add(new _Slice.default(key), new _Slice.default(handleEncoding)); // TODO(postrelease): Add stats and other meta blocks

      await this.writeBlock(metaIndexBlock, metaIndexBlockHandle);
    } // Write index block


    if (this._pendingIndexEntry) {
      this._options.comparator.findShortSuccessor(this._lastKey);

      const handleEncoding = this._pendingHandle.buffer;

      this._indexBlock.add(this._lastKey, new _Slice.default(handleEncoding));

      this._pendingIndexEntry = false;
    }

    await this.writeBlock(this._indexBlock, indexBlockHandle); // Write footer

    this._footer.put({
      metaIndexOffset: metaIndexBlockHandle.offset,
      metaIndexSize: metaIndexBlockHandle.size,
      indexOffset: indexBlockHandle.offset,
      indexSize: indexBlockHandle.size
    });

    await this.appendFile(this._footer.buffer);
    this._offset += this._footer.buffer.length;
    await this.close();
  }

}

exports.default = SSTableBuilder;

class BlockBuilder {
  constructor(options) {
    _defineProperty(this, "blockType", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_buffer", void 0);

    _defineProperty(this, "_restarts", void 0);

    _defineProperty(this, "_finished", void 0);

    _defineProperty(this, "_counter", void 0);

    _defineProperty(this, "_lastKey", void 0);

    this._options = options;
    this._buffer = _Buffer.Buffer.alloc(0);
    this._restarts = [0];
    this._counter = 0;
    this._finished = false;
    this._lastKey = new _Slice.default();
  }

  get buffer() {
    return this._buffer;
  }

  reset() {
    this._buffer = _Buffer.Buffer.alloc(0);
    this._restarts = [0];
    this._counter = 0;
    this._finished = false;
    this._lastKey = new _Slice.default();
  }

  add(key, value) {
    (0, _DBHelper.assert)(!this._finished);
    (0, _DBHelper.assert)(this._counter <= this._options.blockRestartInterval);
    (0, _DBHelper.assert)(this._buffer.length === 0 || this._options.comparator.compare(key, this._lastKey) > 0);
    let shared = 0;

    if (this._counter < this._options.blockRestartInterval) {
      // See how much sharing to do with previous string
      const minLength = Math.min(this._lastKey.size, key.size);

      while (shared < minLength && this._lastKey.buffer[shared] === key.buffer[shared]) {
        shared++;
      }
    } else {
      // Restart compression
      this._restarts.push(this._buffer.length);

      this._counter = 0;
    }

    const nonShared = key.size - shared;
    this._buffer = _Buffer.Buffer.concat([this._buffer, // Add "<shared><non_shared><value_size>" to buffer_
    (0, _Coding.encodeFixed32)(shared), // shared + nonShared === key.size
    (0, _Coding.encodeFixed32)(nonShared), (0, _Coding.encodeFixed32)(value.size), // Add string delta to buffer_ followed by value
    key.buffer.slice(shared), value.buffer]);
    this._lastKey = new _Slice.default(_Buffer.Buffer.concat([this._lastKey.buffer.slice(0, shared), key.buffer.slice(shared)]));
    (0, _DBHelper.assert)(_Buffer.Buffer.compare(this._lastKey.buffer, key.buffer) === 0);
  }

  isEmpty() {
    return this._buffer.length === 0;
  } // Add <Buffer restarts.start>...<Buffer restarts[restarts.end]><Buffer restarts count> to tail


  finish() {
    // Append restart array
    for (let i = 0; i < this._restarts.length; i++) {
      this._buffer = _Buffer.Buffer.concat([this._buffer, (0, _Coding.encodeFixed32)(this._restarts[i])]);
    }

    this._buffer = _Buffer.Buffer.concat([this._buffer, (0, _Coding.encodeFixed32)(this._restarts.length)]);
    this._finished = true;
    return new _Slice.default(this._buffer);
  }

  currentSizeEstimate() {
    return this._buffer.length + // Raw data buffer
    this._restarts.length * _Format.kSizeOfUInt32 + // sizeof(uint32_t), Restart array
    _Format.kSizeOfUInt32 // sizeof(uint32_t)  // Restart array length
    ;
  }

}

class FilterBlockBuilder {
  constructor() {
    _defineProperty(this, "_keys", void 0);

    _defineProperty(this, "_starts", void 0);

    _defineProperty(this, "_result", void 0);

    _defineProperty(this, "_tempKeys", void 0);

    _defineProperty(this, "_filterOffsets", void 0);

    this._keys = _Buffer.Buffer.alloc(0);
    this._starts = [];
    this._result = _Buffer.Buffer.alloc(0);
    this._tempKeys = [];
    this._filterOffsets = [];
  }

  // Offset in _result of each filter
  startBlock(blockOffset) {
    const filterIndex = Math.floor(blockOffset / FilterBlockBuilder.kFilterBase);
    (0, _DBHelper.assert)(filterIndex >= this._filterOffsets.length);

    while (filterIndex > this._filterOffsets.length) {
      this.generateFilter();
    }
  }

  generateFilter() {
    const numKeys = this._starts.length;

    if (numKeys === 0) {
      // Fast path if there are no keys for this filter
      this._filterOffsets.push(this._result.length);

      return;
    } // Make list of keys from flattened key structure


    this._starts.push(this._keys.length);

    for (let i = 0; i < numKeys; i++) {
      // c++ original
      // const char* base = keys_.data() + start_[i];
      // size_t length = start_[i + 1] - start_[i];
      // tmp_keys_[i] = Slice(base, length);
      // c++ translate directly
      // const base = this._starts[i]
      // const length = this._starts[i + 1] - this._starts[i]
      // this._tempKeys[i] = new Slice(this._keys.slice(base, base + length))
      // c++ translate by meaning
      this._tempKeys[i] = new _Slice.default(this._keys.slice(this._starts[i], this._starts[i + 1]));
    } // Generate filter for current set of keys and append to result_.


    this._filterOffsets.push(this._result.length);

    const filter = new _BloomFilter.default();
    filter.putKeys(this._tempKeys, numKeys);
    this._result = _Buffer.Buffer.concat([this._result, filter.buffer]);
    this._keys = _Buffer.Buffer.alloc(0);
    this._tempKeys = [];
    this._starts = [];
  }

  addkey(key) {
    this._starts.push(this._keys.length);

    this._keys = _Buffer.Buffer.concat([this._keys, key.buffer]);
  }

  finish() {
    if (this._starts.length > 0) {
      this.generateFilter();
    } // Append array of per-filter offsets


    const arrayOffset = this._result.length;

    for (let i = 0; i < this._filterOffsets.length; i++) {
      this._result = _Buffer.Buffer.concat([this._result, (0, _Coding.encodeFixed32)(this._filterOffsets[i])]);
    }

    this._result = _Buffer.Buffer.concat([this._result, (0, _Coding.encodeFixed32)(arrayOffset), _Buffer.Buffer.fromUnknown([FilterBlockBuilder.kFilterBaseLg]) // Save encoding parameter in result
    ]);
    return new _Slice.default(this._result);
  }

}

_defineProperty(FilterBlockBuilder, "kFilterBaseLg", 11);

_defineProperty(FilterBlockBuilder, "kFilterBase", 1 << FilterBlockBuilder.kFilterBaseLg);
//# sourceMappingURL=SSTableBuilder.js.map