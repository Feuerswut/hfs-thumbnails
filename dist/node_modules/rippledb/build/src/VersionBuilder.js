"use strict";

exports.__esModule = true;
exports.default = void 0;

var _Format = require("./Format");

var _VersionFormat = require("./VersionFormat");

var _DBHelper = require("./DBHelper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class VersionBuilder {
  constructor(versionSet, base) {
    _defineProperty(this, "_versionSet", void 0);

    _defineProperty(this, "_base", void 0);

    _defineProperty(this, "_levels", void 0);

    _defineProperty(this, "cmp", void 0);

    this._versionSet = versionSet;
    this._base = base;
    this._levels = Array.from({
      length: _Format.Config.kNumLevels
    }, () => ({
      addedFiles: new _VersionFormat.FileSet(this.cmp),
      deletedFiles: new Set()
    }));
    base.ref();
    const cmp = new _VersionFormat.BySmallestKey(versionSet.internalKeyComparator);
    this.cmp = cmp;

    for (let level = 0; level < _Format.Config.kNumLevels; level++) {
      this._levels[level].addedFiles = new _VersionFormat.FileSet(cmp);
    }
  }

  // Apply all of the edits in *edit to the current state.
  apply(edit) {
    // Update compaction pointers
    // compactPointers: type = <int, InternalKey>
    for (let i = 0; i < edit.compactPointers.length; i++) {
      const level = edit.compactPointers[i].level;
      this._versionSet.compactPointers[level] = edit.compactPointers[i].internalKey;
    } // traverse deleted_files_ put file to each level's deleted_files


    for (let i = 0; i < edit.deletedFiles.length; i++) {
      const {
        level,
        fileNum
      } = edit.deletedFiles[i];

      this._levels[level].deletedFiles.add(fileNum);
    } // traverse new files


    for (const file of edit.newFiles) {
      const {
        level,
        fileMetaData
      } = file;
      fileMetaData.refs = 1;
      fileMetaData.allowedSeeks = Math.floor(file.fileMetaData.fileSize / 16384); // 16kb, experience value

      if (fileMetaData.allowedSeeks < 100) fileMetaData.allowedSeeks = 100;

      this._levels[level].deletedFiles.delete(fileMetaData.number);

      this._levels[level].addedFiles.add(fileMetaData);
    }
  } // Save the current state in `ver`.


  saveTo(ver) {
    const cmp = new _VersionFormat.BySmallestKey(this._versionSet.internalKeyComparator); // traverse every level and put added files in right
    // position [ baseFiles_A, addedFiles, baseFiels_B ) ]

    for (let level = 0; level < _Format.Config.kNumLevels; level++) {
      // Merge the set of added files with the set of pre-existing files.
      // Drop any deleted files.  Store the result in ver.
      const addedFileIterator = this._levels[level].addedFiles.iterator();

      const baseFilesInThisLevel = this._base.files[level].sort((a, b) => cmp.operator(a, b) ? -1 : 1);

      let addedFile = addedFileIterator.next();
      let i = 0;

      while (true) {
        if (baseFilesInThisLevel.length === 0) {
          // empty level, just push addedFile
          break;
        }

        const baseFile = baseFilesInThisLevel[i++];

        if (!addedFile.done) {
          if (cmp.operator(baseFile, addedFile.value)) {
            // Add all smaller files listed in base_
            this.maybeAddFile(ver, level, baseFile);
          } else {
            i--;
            this.maybeAddFile(ver, level, addedFile.value);
            addedFile = addedFileIterator.next();
          }
        } else {
          this.maybeAddFile(ver, level, baseFile);
        }

        if (i >= baseFilesInThisLevel.length) break;
      }

      while (!addedFile.done) {
        this.maybeAddFile(ver, level, addedFile.value);
        addedFile = addedFileIterator.next();
      }
    }
  }

  maybeAddFile(ver, level, file) {
    if (this._levels[level].deletedFiles.has(file.number)) {// File is deleted: do nothing
    } else {
      const files = ver.files[level];

      if (level > 0 && files.length > 0) {
        // Must not overlap: smallest key in file should bigger
        // then this level biggest key so can push file to this
        // level tail
        (0, _DBHelper.assert)(this._versionSet.internalKeyComparator.compare(files[files.length - 1].largest, file.smallest) < 0);
      }

      file.refs++;
      ver.files[level].push(file);
    }
  }

}

exports.default = VersionBuilder;
//# sourceMappingURL=VersionBuilder.js.map