"use strict";

exports.__esModule = true;
exports.default = void 0;

var _Slice = _interopRequireDefault(require("./Slice"));

var _SSTableFooter = _interopRequireDefault(require("./SSTableFooter"));

var _SSTableBlock = _interopRequireDefault(require("./SSTableBlock"));

var _SSTableFilterBlock = _interopRequireDefault(require("./SSTableFilterBlock"));

var _Format = require("./Format");

var _Status = _interopRequireDefault(require("./Status"));

var _Options = require("./Options");

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Reader
class SSTable {
  static async readBlock(file, options, handle) {
    const result = {
      data: new _Slice.default(),
      cachable: false,
      heapAllocated: false
    }; // Read the block contents as well as the type/crc footer.
    // See table_builder.cc for the code that built this structure.

    const n = handle.size;

    const data = _Buffer.Buffer.alloc(handle.size + _Format.kBlockTrailerSize);

    const {
      bytesRead
    } = await file.read(data, 0, data.length, handle.offset);

    if (bytesRead !== handle.size + _Format.kBlockTrailerSize) {
      throw new Error("truncated block read");
    } // TODO Check the crc of the type and the block contents


    switch (data[n]) {
      case _Format.CompressionTypes.none:
        result.data = new _Slice.default(data.slice(0, n));
        break;
      // TODO Compression

      default:
        throw new Error("bad block type");
    }

    return result;
  }

  static async open(options, file) {
    const stat = await file.stat();

    if (stat.size < _SSTableFooter.default.kEncodedLength) {
      throw new Error("file is too short to be an sstable");
    }

    const footerBuf = _Buffer.Buffer.alloc(_SSTableFooter.default.kEncodedLength);

    await file.read(footerBuf, 0, footerBuf.length, stat.size - _SSTableFooter.default.kEncodedLength);
    const footer = new _SSTableFooter.default(footerBuf);
    const indexBlockContents = await this.readBlock(file, _Options.defaultReadOptions, footer.indexHandle);
    const indexBlock = new _SSTableBlock.default(indexBlockContents);
    indexBlock.blockType = "indexblock";
    const table = new SSTable({
      file,
      options,
      indexBlock,
      metaIndexHandle: footer.metaIndexHandle
    });
    await table.readMeta(footer);
    return table;
  }

  constructor(rep) {
    _defineProperty(this, "_file", void 0);

    _defineProperty(this, "_cacheId", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_indexBlock", void 0);

    _defineProperty(this, "_filterReader", void 0);

    this._file = rep.file;
    this._options = rep.options;
    this._indexBlock = rep.indexBlock;
    this._cacheId = rep.options.blockCache.newId();
  }

  async readMeta(footer) {
    if (!this._options.filterPolicy) {
      return; // Do not need any metadata
    }

    const contents = await SSTable.readBlock(this._file, _Options.defaultReadOptions, footer.metaIndexHandle);
    const meta = new _SSTableBlock.default(contents);
    meta.blockType = "metaindexblock";
    const key = new _Slice.default("filter." + this._options.filterPolicy.name());

    for (const entry of meta.iterator(this._options.comparator)) {
      if (entry.key.isEqual(key)) {
        await this.readFilter(entry.value.buffer);
      }
    }
  }

  async readFilter(filterHandleBuffer) {
    const filterHandle = _Format.BlockHandle.from(filterHandleBuffer);

    const readOptions = { ..._Options.defaultReadOptions
    };
    const block = await SSTable.readBlock(this._file, readOptions, filterHandle);
    this._filterReader = new _SSTableFilterBlock.default(this._options.filterPolicy, block.data);
  } // key: internalKey


  async get(target) {
    const targetInternalKey = _Format.InternalKey.from(target);

    for (const handleValue of this._indexBlock.iterator(this._options.comparator)) {
      const handle = _Format.BlockHandle.from(handleValue.value.buffer);

      if (!!this._filterReader && !this._filterReader.keyMayMatch(handle.offset, target)) {// Not found
      } else {
        for await (const entry of this.blockIterator(this, this._options, handle, false, "datablock")) {
          const entryInternalKey = _Format.InternalKey.from(entry.key);

          if (entryInternalKey.userKey.isEqual(targetInternalKey.userKey) && entryInternalKey.sequence <= targetInternalKey.sequence) {
            // do not handle value type here, handle it at `Version.saveValue`
            return new _Status.default(Promise.resolve(entry));
          }
        }
      }
    }

    return _Status.default.createNotFound();
  }

  async *entryIterator(reverse = false) {
    for (const handleValue of this._indexBlock.iterator(this._options.comparator, reverse)) {
      const handle = _Format.BlockHandle.from(handleValue.value.buffer);

      yield* this.blockIterator(this, this._options, handle, reverse, "datablock");
    }
  } // Convert an index iterator value (i.e., an encoded BlockHandle)
  // into an iterator over the contents of the corresponding block.


  async *blockIterator(table, options, handle, reverse = false, blockType) {
    const key = _Buffer.Buffer.concat([(0, _Coding.encodeFixed64)(this._cacheId), (0, _Coding.encodeFixed64)(handle.offset)]);

    let dataBlock = this._options.blockCache.get(key);

    if (!dataBlock) {
      const data = _Buffer.Buffer.alloc(handle.size);

      const {
        bytesRead
      } = await this._file.read(data, 0, data.length, handle.offset);
      (0, _DBHelper.assert)(bytesRead === data.length);
      const contents = {
        data: new _Slice.default(data)
      };
      dataBlock = new _SSTableBlock.default(contents);
      if (blockType) dataBlock.blockType = blockType;

      this._options.blockCache.set(key, dataBlock);
    }

    yield* dataBlock.iterator(options.comparator, reverse);
  }

}

exports.default = SSTable;
//# sourceMappingURL=SSTable.js.map