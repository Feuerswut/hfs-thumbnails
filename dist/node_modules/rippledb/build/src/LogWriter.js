"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

var _Crc = require("./Crc32");

var _LogFormat = require("./LogFormat");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class LogWriter {
  constructor(_file) {
    _defineProperty(this, "_file", void 0);

    _defineProperty(this, "_blockOffset", void 0);

    _defineProperty(this, "close", async () => {
      (0, _DBHelper.assert)(!!this._file);
      const file = this._file;
      delete this._file;

      try {
        await file.close();
      } catch (e) {}
    });

    _defineProperty(this, "emitPhysicalRecord", async (record, type) => {
      const head = _Buffer.Buffer.alloc(_LogFormat.kHeaderSize);

      const length = record.length;
      head[4] = length & 0xff;
      head[5] = length >> 8;
      head[6] = type;

      const merged = _Buffer.Buffer.concat([_Buffer.Buffer.fromUnknown([type]), record, _Buffer.Buffer.fromUnknown([record.length])]);

      const crc = (0, _Crc.crc32)(merged);
      head.fillBuffer(crc, 0, 4);
      this._blockOffset += record.length + _LogFormat.kHeaderSize;
      await this.appendFile(_Buffer.Buffer.concat([head, record]));
    });

    _defineProperty(this, "addRecord", async recordOp => {
      let hasFirstRecordCreated = false;
      let left = recordOp.size;
      let position = 0;

      while (left > 0) {
        const leftover = _LogFormat.kBlockSize - this._blockOffset;
        (0, _DBHelper.assert)(leftover >= 0);

        if (leftover < _LogFormat.kHeaderSize) {
          // Switch to a new block
          if (leftover > 0) {
            // Fill the trailer (literal below relies on kHeaderSize being 7)
            (0, _DBHelper.assert)(_LogFormat.kHeaderSize == 7);
            await this.appendFile(_Buffer.Buffer.alloc(leftover));
          }

          this._blockOffset = 0;
        } // Invariant: we never leave < kHeaderSize bytes in a block.


        (0, _DBHelper.assert)(_LogFormat.kBlockSize - this._blockOffset - _LogFormat.kHeaderSize >= 0);
        const avail = _LogFormat.kBlockSize - this._blockOffset - _LogFormat.kHeaderSize;
        const fragmentLength = left < avail ? left : avail;
        let recordType;
        const isEnd = left === fragmentLength;

        if (!hasFirstRecordCreated && isEnd) {
          recordType = _LogFormat.RecordType.kFullType;
        } else if (!hasFirstRecordCreated) {
          recordType = _LogFormat.RecordType.kFirstType;
        } else if (isEnd) {
          recordType = _LogFormat.RecordType.kLastType;
        } else {
          recordType = _LogFormat.RecordType.kMiddleType;
        }

        await this.emitPhysicalRecord(recordOp.buffer.slice(position, position + fragmentLength), recordType);
        hasFirstRecordCreated = true;
        position += fragmentLength;
        left -= fragmentLength;
      }
    });

    this._blockOffset = 0;
    this._file = _file;
  }

  async appendFile(buf) {
    await this._file.appendFile(buf, {});
  }

}

exports.default = LogWriter;
//# sourceMappingURL=LogWriter.js.map