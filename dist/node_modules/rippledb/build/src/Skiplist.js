"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Slice = _interopRequireDefault(require("./Slice"));

var _SkiplistNode = _interopRequireDefault(require("./SkiplistNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const PROBABILITY = 1 / Math.E;
const kMaxHeight = 12; // Math.round(Math.log(this.maxsize, 2))
// const kBranching = 4

class Skiplist {
  constructor(keyComparator, maxsize = 65535) {
    _defineProperty(this, "keyComparator", void 0);

    _defineProperty(this, "maxsize", void 0);

    _defineProperty(this, "level", void 0);

    _defineProperty(this, "head", void 0);

    this.maxsize = maxsize;
    this.level = 0; // When initial，tail is null head link to tail
    // [] -------> []
    // [] -------> []
    // [] -------> []
    // [] -------> []
    // [] -------> []
    // head       tail

    this.keyComparator = keyComparator;
    this.head = new _SkiplistNode.default(kMaxHeight, new _Slice.default());
  }

  isKeyAfterNode(key, node) {
    return !!node && this.keyComparator(node.key, key) < 0;
  }

  generateNodeLevel() {
    let nodeLevel = 1;
    const max = Math.min(kMaxHeight, this.level + 1);

    while (Math.random() < PROBABILITY && nodeLevel < max) {
      nodeLevel++;
    }

    (0, _DBHelper.assert)(nodeLevel > 0);
    (0, _DBHelper.assert)(nodeLevel <= kMaxHeight);
    return nodeLevel;
  }

  findGreaterOrEqual(key, shouldUpdatePrevNodes) {
    let level = kMaxHeight;
    let current = this.head;

    while (true) {
      const next = current.next(level); // if current node's next is null
      //  if level === 0，then loop end, the inserted key is biggest
      //  else keep find in smaller level
      //  if inserted key is small then current key，then loop end
      //   if next nodes's key is smaller then inserted key，then check if next node exist
      //   next node's key is bigger

      if (this.isKeyAfterNode(key, next)) {
        current = next;
      } else {
        if (shouldUpdatePrevNodes) shouldUpdatePrevNodes[level] = current;

        if (level === 0) {
          return next;
        } else {
          level--;
        }
      }
    }
  }

  findLast() {
    let node = this.head;
    let level = this.level;

    while (true) {
      const next = node.next(level);

      if (!next) {
        if (level === 0) return node;
        level--;
      } else {
        node = next;
      }
    }
  }

  findLessThan(key) {
    let node = this.head;
    let level = this.level;

    while (true) {
      (0, _DBHelper.assert)(node === this.head || this.keyComparator(node.key, key) < 0);
      const next = node.next(level);

      if (!next || this.keyComparator(next.key, key) >= 0) {
        if (level === 0) return node;
        level--;
      } else {
        node = next;
      }
    }
  }

  *iterator(reverse = false) {
    if (!reverse) {
      let current = this.head;

      while (true) {
        if (!current) break;
        if (!current.next(0)) break;
        yield current.next(0).key;
        current = current.next(0);
      }
    } else {
      // Instead of using explicit "prev" links, we just search for the
      // last node that falls before key.
      let current = this.findLast();

      while (true) {
        if (current === this.head) break;
        yield current.key;
        const prev = this.findLessThan(current.key);
        current = prev;
      }
    }
  }

  isEqual(a, b) {
    return a.isEqual(b);
  } // TODO maybe there is something error
  //   Advance to the first entry with a key >= target


  seek(key) {
    const prevNode = this.findGreaterOrEqual(key);
    return prevNode;
  }

  put(key) {
    const shouldUpdatePrevNodes = new Array(kMaxHeight);
    const prevNode = this.findGreaterOrEqual(key, shouldUpdatePrevNodes);
    (0, _DBHelper.assert)(!prevNode || !this.isEqual(key, prevNode.key));
    const nodeLevel = this.generateNodeLevel();

    if (nodeLevel > this.level) {
      for (let i = this.level; i < nodeLevel; i++) {
        shouldUpdatePrevNodes[i] = this.head;
      }

      this.level = nodeLevel;
    }

    const node = new _SkiplistNode.default(nodeLevel, key);

    for (let i = 0; i < nodeLevel; i++) {
      if (shouldUpdatePrevNodes[i]) {
        node.levels[i] = shouldUpdatePrevNodes[i].levels[i];
        shouldUpdatePrevNodes[i].levels[i] = node;
      }
    }
  }

}

exports.default = Skiplist;
//# sourceMappingURL=Skiplist.js.map