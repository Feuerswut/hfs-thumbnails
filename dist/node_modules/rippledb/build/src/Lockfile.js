"use strict";

exports.__esModule = true;
exports.Lockfile = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) 2018-present, heineiuo.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
class Lockfile {
  constructor(filename, options) {
    _defineProperty(this, "filetime", void 0);

    _defineProperty(this, "filename", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "refreshLockTimer", void 0);

    _defineProperty(this, "_locked", false);

    _defineProperty(this, "stale", void 0);

    this.filename = filename;
    this.options = options;
    this.filetime = options.env.platform() === "win32" ? "mtime" : "ctime";
    this.stale = options.lockfileStale;
    this.options.env.onExit(() => {
      // if db has been destoryed manully, unlink will fail.
      try {
        this.options.env.unlinkSync(this.filename);
      } catch (e) {}
    });
  }

  get locked() {
    return this._locked;
  }

  async unlock() {
    try {
      // if db has been destoryed manully, unlink will fail.
      await this.options.env.unlink(this.filename);
    } catch (e) {}

    this._locked = false;
    clearInterval(this.refreshLockTimer);
  }

  async waitUntilExpire(startTime = Date.now()) {
    try {
      const fd = await this.options.env.open(this.filename, "r");

      try {
        const stats = await fd.stat();
        const filetime = new Date(stats[this.filetime]).getTime();
        if (Date.now() > filetime + this.stale + 1000) return true;
      } catch (e) {} finally {
        await fd.close();
      } // wait time should be longer


      if (Date.now() > startTime + this.stale * 2 + 1000) return false;
      await new Promise(resolve => setTimeout(resolve, this.stale / 2));
      return await this.waitUntilExpire(startTime);
    } catch (e) {
      return false;
    }
  }

  async waitUntilOk() {
    try {
      const fd = await this.options.env.open(this.filename, "r");
      await fd.close(); // file exist, wait file expire

      const expired = await this.waitUntilExpire();
      return expired;
    } catch (e) {
      if (e.code === "ENOENT") {
        return true;
      }

      return false;
    }
  }

  async writeSomething() {
    try {
      await this.options.env.writeFile(this.filename, ``);
      this._locked = true;
    } catch (e) {}
  }

  async lock() {
    const ok = await this.waitUntilOk();

    if (!ok) {
      throw new Error("Lock fail");
    }

    await this.writeSomething();
    this.refreshLockTimer = setInterval(() => this.writeSomething(), this.stale / 2);
  }

}

exports.Lockfile = Lockfile;
//# sourceMappingURL=Lockfile.js.map