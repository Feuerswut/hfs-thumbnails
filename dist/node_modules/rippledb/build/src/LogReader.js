"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

var _Slice = _interopRequireDefault(require("./Slice"));

var _LogFormat = require("./LogFormat");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class LogReader {
  constructor(file) {
    _defineProperty(this, "_file", void 0);

    this._file = file;
  }

  async close() {
    if (!!this._file) {
      const file = this._file;
      delete this._file;

      try {
        await file.close();
      } catch (e) {}
    }
  }

  async *iterator() {
    const buf = _Buffer.Buffer.fromUnknown(new ArrayBuffer(_LogFormat.kBlockSize));

    let blockIndex = -1;

    let latestOpBuf = _Buffer.Buffer.alloc(0);

    let latestType = null;
    let bufHandledPosition = 0;

    while (true) {
      // read file fragment to `buf`
      if (blockIndex === -1 || bufHandledPosition >= _LogFormat.kBlockSize - _LogFormat.kHeaderSize) {
        const position = ++blockIndex * _LogFormat.kBlockSize;
        const {
          bytesRead
        } = await this._file.read(buf, 0, _LogFormat.kBlockSize, position);

        if (bytesRead === 0) {
          await this.close();
          return;
        }

        bufHandledPosition = 0;
        continue;
      } // buf may be re-fill, to avoid this, copy it


      const record = this.readPhysicalRecord(_Buffer.Buffer.fromUnknown(buf.slice(bufHandledPosition)));
      bufHandledPosition += record.length + _LogFormat.kHeaderSize;

      if (record.type === _LogFormat.RecordType.kFullType) {
        const opSlice = new _Slice.default(record.data.buffer);
        yield opSlice;
      } else if (record.type === _LogFormat.RecordType.kLastType) {
        (0, _DBHelper.assert)(latestType !== _LogFormat.RecordType.kLastType);
        latestOpBuf = _Buffer.Buffer.concat([latestOpBuf, record.data.buffer]);
        const opSlice = new _Slice.default(latestOpBuf);
        latestOpBuf = _Buffer.Buffer.alloc(0);
        yield opSlice;
      } else if (record.type === _LogFormat.RecordType.kFirstType) {
        (0, _DBHelper.assert)(latestType !== _LogFormat.RecordType.kFirstType);
        latestOpBuf = record.data.buffer;
      } else if (record.type === _LogFormat.RecordType.kMiddleType) {
        latestOpBuf = _Buffer.Buffer.concat([latestOpBuf, record.data.buffer]);
      } else if (record.type === _LogFormat.RecordType.kZeroType) {
        // skip this block
        latestType = record.type;
        bufHandledPosition = _LogFormat.kBlockSize;
      }

      latestType = record.type;
    }
  }

  readPhysicalRecord(buf) {
    const head = buf.slice(0, _LogFormat.kHeaderSize);
    const recordType = head[6];
    const head4 = head[4] & 0xff;
    const head5 = head[5] & 0xff;
    const length = head4 | head5 << 8;
    const data = new _Slice.default(buf.slice(_LogFormat.kHeaderSize, _LogFormat.kHeaderSize + length));
    return {
      length,
      data,
      type: recordType
    };
  }

}

exports.default = LogReader;
//# sourceMappingURL=LogReader.js.map