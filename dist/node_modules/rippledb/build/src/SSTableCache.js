"use strict";

exports.__esModule = true;
exports.TableCache = void 0;

var _Status = _interopRequireDefault(require("./Status"));

var _SSTable = _interopRequireDefault(require("./SSTable"));

var _Filename = require("./Filename");

var _IteratorHelper = _interopRequireDefault(require("./IteratorHelper"));

var _Cache = _interopRequireDefault(require("./Cache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class TableCache {
  // TODO entries: LRUCache capacity
  constructor(dbpath, options, entries) {
    _defineProperty(this, "_destroyed", false);

    _defineProperty(this, "_env", void 0);

    _defineProperty(this, "_dbpath", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_cache", void 0);

    this._env = options.env;
    this._dbpath = dbpath;
    this._options = options;
    this._cache = new _Cache.default({
      max: entries,

      async dispose(key, tf) {
        try {
          await tf.file.close();
        } catch (e) {}
      }

    });
  }

  async destroy() {
    this._destroyed = true;

    this._cache.reset();

    await new Promise(resolve => setTimeout(resolve, 100));
  }

  async get(options, fileNumber, fileSize, key, arg, // state.saver, set kNotFound if not found
  saveValue) {
    let status = await this.findTable(fileNumber, fileSize);

    if (await status.ok()) {
      const tf = await status.promise;
      const table = tf.table; // get value from table file

      status = await table.get(key);
    }

    if (await status.ok()) {
      const {
        key,
        value
      } = await status.promise;
      saveValue(arg, key, value);
    }

    return status;
  }

  async findTable(fileNumber, fileSize) {
    let status = new _Status.default();

    const cachedTf = this._cache.get(fileNumber);

    if (!cachedTf) {
      const tableFilename = (0, _Filename.getTableFilename)(this._dbpath, fileNumber);
      status = new _Status.default(this._env.open(tableFilename, "r+"));
      const tf = {};

      if (await status.ok()) {
        tf.file = await status.promise;
        status = new _Status.default(_SSTable.default.open(this._options, tf.file));
      }

      if (await status.ok()) {
        tf.table = await status.promise;

        this._cache.set(fileNumber, tf);

        status = new _Status.default(Promise.resolve(tf));
      } else {// We do not cache error results so that if the error is transient,
        // or somebody repairs the file, we recover automatically.
      }
    } else {
      status = new _Status.default(Promise.resolve(cachedTf));
    }

    return status;
  }

  async *entryIterator(options, fileNumber, fileSize) {
    const status = await this.findTable(fileNumber, fileSize);

    if (await status.ok()) {
      const tf = await status.promise;
      yield* _IteratorHelper.default.wrap(tf.table.entryIterator(), async () => {
        await tf.file.close();
      });
    } else {
      this._options.log(`Open Table file(${fileNumber}) fail.`);

      throw new Error(`Open Table file(${fileNumber}) fail.`);
    }
  }

}

exports.TableCache = TableCache;
//# sourceMappingURL=SSTableCache.js.map