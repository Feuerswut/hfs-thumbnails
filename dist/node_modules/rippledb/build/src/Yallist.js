"use strict";

exports.__esModule = true;
exports.Yallist = exports.YallistNode = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Rewrite to TypeScript https://github.com/isaacs/yallist
class YallistNode {
  constructor(value, prev, next, list) {
    _defineProperty(this, "value", void 0);

    _defineProperty(this, "list", void 0);

    _defineProperty(this, "prev", void 0);

    _defineProperty(this, "next", void 0);

    this.list = list;
    this.value = value;

    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }

    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }

}

exports.YallistNode = YallistNode;

class Yallist {
  constructor() {
    _defineProperty(this, "length", 0);

    _defineProperty(this, "tail", void 0);

    _defineProperty(this, "head", void 0);

    this.tail = null;
    this.head = null;
  }

  push(item) {
    this.tail = new YallistNode(item, this.tail, null, this);

    if (!this.head) {
      this.head = this.tail;
    }

    this.length++;
    return this.length;
  }

  unshift(item) {
    this.head = new YallistNode(item, null, this.head, this);

    if (!this.tail) {
      this.tail = this.head;
    }

    this.length++;
    return this.length;
  }

  unshiftNode(node) {
    if (node === this.head) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    const head = this.head;
    node.list = this;
    node.next = head;

    if (head) {
      head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    this.length++;
  }

  removeNode(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }

    const next = node.next;
    const prev = node.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }

    if (node === this.tail) {
      this.tail = prev;
    }

    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  }

  forEach(callbackFn) {
    for (let walker = this.head, i = 0; walker !== null; i++) {
      callbackFn(walker.value, i, this);
      walker = walker.next;
    }
  }

  map(callbackFn) {
    const res = new Yallist();

    for (let walker = this.head; walker !== null;) {
      res.push(callbackFn(walker.value, this));
      walker = walker.next;
    }

    return res;
  }

  toArray() {
    const arr = new Array(this.length);

    for (let i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }

    return arr;
  }

}

exports.Yallist = Yallist;
//# sourceMappingURL=Yallist.js.map