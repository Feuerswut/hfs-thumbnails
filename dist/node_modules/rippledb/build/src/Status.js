"use strict";

exports.__esModule = true;
exports.default = exports.StatusError = void 0;

var _DBHelper = require("./DBHelper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Code;

(function (Code) {
  Code[Code["kOk"] = 0] = "kOk";
  Code[Code["kNotFound"] = 1] = "kNotFound";
  Code[Code["kCorruption"] = 2] = "kCorruption";
  Code[Code["kNotSupported"] = 3] = "kNotSupported";
  Code[Code["kInvalidArgument"] = 4] = "kInvalidArgument";
  Code[Code["kIOError"] = 5] = "kIOError";
})(Code || (Code = {}));

class StatusError extends Error {
  constructor(code, message) {
    super(message);

    _defineProperty(this, "_code", void 0);

    this._code = code;
  }

}

exports.StatusError = StatusError;

class Status {
  static createNotFound(message) {
    return new Status(Promise.reject(new StatusError(Code.kNotFound, message)));
  }

  static createCorruption(message) {
    return new Status(Promise.reject(new StatusError(Code.kCorruption, message)));
  }

  constructor(promise) {
    _defineProperty(this, "_error", void 0);

    _defineProperty(this, "_promise", void 0);

    _defineProperty(this, "_code", void 0);

    _defineProperty(this, "_finish", void 0);

    this._promise = promise;
    this._finish = false;
  }

  get promise() {
    return this._promise;
  }

  get error() {
    return this._error;
  }

  async wait() {
    if (this._finish) return;

    try {
      await this._promise;
    } catch (e) {
      if (e._code) this._code = e._code;
      this._error = e;
    } finally {
      this._finish = true;
    }
  }

  async ok() {
    await this.wait();
    return !this._error;
  }

  message() {
    (0, _DBHelper.assert)(this._finish);

    if (this._error) {
      return this._error.message;
    }
  }

  isNotFound() {
    (0, _DBHelper.assert)(this._finish);
    return this._code === Code.kNotFound;
  }

  isCorruption() {
    (0, _DBHelper.assert)(this._finish);
    return this._code === Code.kCorruption;
  }

  isIOError() {
    (0, _DBHelper.assert)(this._finish);
    return this._code === Code.kIOError;
  }

  isNotSupportedError() {
    (0, _DBHelper.assert)(this._finish);
    return this._code === Code.kNotSupported;
  }

  isInvalidArgument() {
    (0, _DBHelper.assert)(this._finish);
    return this._code === Code.kNotSupported;
  }

}

exports.default = Status;
//# sourceMappingURL=Status.js.map