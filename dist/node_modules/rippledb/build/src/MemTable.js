"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

var _Format = require("./Format");

var _Skiplist = _interopRequireDefault(require("./Skiplist"));

var _Slice = _interopRequireDefault(require("./Slice"));

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MemTable {
  static getValueSlice(key) {
    const internalKeySize = _DBHelper.varint.decode(key.buffer);

    const valueType = _DBHelper.varint.decode(key.buffer.slice(internalKeySize));

    if (valueType === _Format.ValueType.kTypeDeletion) {
      return null;
    }

    const valueBuffer = key.buffer.slice(_DBHelper.varint.decode.bytes + internalKeySize);

    const valueSize = _DBHelper.varint.decode(valueBuffer);

    const value = valueBuffer.slice(_DBHelper.varint.decode.bytes, _DBHelper.varint.decode.bytes + valueSize);
    return new _Slice.default(value);
  } // memkey: <Buffer internalkeyzise><Buffer internalkey><Buffer valuesize><Buffer value>


  static getEntryFromMemTableKey(key) {
    let index = 0;

    const internalKeySize = _DBHelper.varint.decode(key.buffer);

    index += _DBHelper.varint.decode.bytes;
    const internalKey = new _Slice.default(key.buffer.slice(index, index + internalKeySize));
    index += internalKeySize;

    const valueSize = _DBHelper.varint.decode(key.buffer.slice(index));

    index += _DBHelper.varint.decode.bytes;
    const value = new _Slice.default(key.buffer.slice(index, index + valueSize));
    return {
      key: internalKey,
      value
    };
  }

  constructor(internalKeyComparator) {
    _defineProperty(this, "_immutable", void 0);

    _defineProperty(this, "_list", void 0);

    _defineProperty(this, "_size", void 0);

    _defineProperty(this, "refs", void 0);

    _defineProperty(this, "internalKeyComparator", void 0);

    _defineProperty(this, "keyComparator", (a, b) => {
      const internalKeyBufA = (0, _Coding.getLengthPrefixedSlice)(a);
      const internalKeyBufB = (0, _Coding.getLengthPrefixedSlice)(b);
      return this.internalKeyComparator.compare(internalKeyBufA, internalKeyBufB);
    });

    this._immutable = false;
    this.internalKeyComparator = internalKeyComparator;
    this._list = new _Skiplist.default(this.keyComparator);
    this._size = 0;
    this.refs = 0;
  } // a and b is memtable key


  ref() {
    this.refs++;
  }

  unref() {
    this.refs--;
  }

  get size() {
    return this._size;
  }

  get immutable() {
    return this._immutable;
  }

  set immutable(next) {
    if (next) this._immutable = true;
  }

  add(sequence, valueType, key, value) {
    const keySize = key.length;
    const valueSize = !value ? 0 : value.length;
    const internalKeySize = keySize + 8; // sequence=7bytes, type = 1byte

    const valueSizeBuf = _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(valueSize));

    let encodedLength = internalKeySize + valueSize + _DBHelper.varint.encode.bytes;

    const internalKeySizeBuf = _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(internalKeySize));

    encodedLength += _DBHelper.varint.encode.bytes;
    /**
     * encoded(internal_key_size) | key | sequence(7Bytes) | type (1Byte) | encoded(value_size) | value
     * 1. Lookup key/ Memtable Key: encoded(internal_key_size) --- type(1Byte)
     * 2. Internal key: key --- type(1Byte)
     * 3. User key: key
     */

    const sequenceBuf = (0, _Coding.encodeFixed64)(sequence);
    sequenceBuf.fillInt(valueType, 7, 8);
    const buf = new _Slice.default(_Buffer.Buffer.concat([internalKeySizeBuf, key.buffer, sequenceBuf, valueSizeBuf, !value ? _Buffer.Buffer.alloc(0) : value.buffer]));
    (0, _DBHelper.assert)(encodedLength === buf.length, "Incorrect length"); // buf include both key and value

    this._list.put(buf);

    this._size += buf.length;
  } // entry format is:
  //    klength  varint32
  //    userkey  char[klength]
  //    tag      uint64
  //    vlength  varint32
  //    value    char[vlength]
  // Check that it belongs to same user key.  We do not check the
  // sequence number since the Seek() call above should have skipped
  // all entries with overly large sequence numbers.
  //
  // this key is lookup key


  get(key) {
    const memkey = key.memKey;

    const node = this._list.seek(memkey);

    if (!!node) {
      const entry = MemTable.getEntryFromMemTableKey(node.key);

      const internalKey = _Format.InternalKey.from(entry.key);

      if (this.internalKeyComparator.userComparator.compare(internalKey.userKey, key.userKey) === 0) {
        return {
          key: entry.key,
          value: entry.value,
          type: internalKey.type
        };
      }
    }
  }

  *iterator(reverse = false) {
    for (const value of this._list.iterator(reverse)) {
      yield MemTable.getEntryFromMemTableKey(value);
    }
  }

}

exports.default = MemTable;
//# sourceMappingURL=MemTable.js.map