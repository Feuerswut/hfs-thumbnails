"use strict";

exports.__esModule = true;
exports.default = void 0;

var _DBHelper = require("./DBHelper");

var _Slice = _interopRequireDefault(require("./Slice"));

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// MetaBlock format is different with other blocks
// filter_index = (blockOffset / kFilterBase);
class SSTableFilterBlock {
  constructor(policy, data) {
    _defineProperty(this, "_buffer", void 0);

    _defineProperty(this, "_data", void 0);

    _defineProperty(this, "_offset", void 0);

    _defineProperty(this, "_size", void 0);

    _defineProperty(this, "_policy", void 0);

    _defineProperty(this, "_num", void 0);

    _defineProperty(this, "_baseLg", void 0);

    this._buffer = data.buffer;
    this._policy = policy;
    this._num = 0;
    this._baseLg = 0;
    const n = data.size;
    if (n < 5) return; // 1 byte for base_lg_ and 4 for start of offset array

    this._baseLg = data.buffer[data.length - 1];
    const lastWord = (0, _Coding.decodeFixed32)(data.buffer.slice(n - 5));
    if (lastWord > n - 5) return;
    this._buffer = data.buffer;
    this._data = 0;
    this._offset = lastWord;
    this._num = (n - 5 - lastWord) / 4;
  }

  // Encoding parameter (see kFilterBaseLg in .cc file)
  get size() {
    return this._size;
  }

  get buffer() {
    return this._buffer;
  }

  get beginningOfOffset() {
    let buf;

    if (this._offset === 0 && this._size === this._buffer.length) {
      buf = this._buffer;
    } else {
      buf = this._buffer.slice(this._offset, this._size);
    }

    return _DBHelper.varint.decode(buf, buf.length - 2);
  }

  keyMayMatch(blockOffset, key) {
    const index = blockOffset >> this._baseLg;

    if (index < this._num) {
      const start = (0, _Coding.decodeFixed32)(this._buffer.slice(this._offset + index * 4));
      const limit = (0, _Coding.decodeFixed32)(this._buffer.slice(this._offset + index * 4 + 4));

      if (start <= limit && limit <= this._offset + this._size) {
        const filter = new _Slice.default(this._buffer.slice(this._offset + start, this._offset + limit - start));
        return this._policy.keyMayMatch(key, filter);
      } else if (start == limit) {
        // Empty filters do not match any keys
        return false;
      }
    }

    return true; // Errors are treated as potential matches
  }

}

exports.default = SSTableFilterBlock;
//# sourceMappingURL=SSTableFilterBlock.js.map