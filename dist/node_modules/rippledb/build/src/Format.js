"use strict";

exports.__esModule = true;
exports.extractUserKey = extractUserKey;
exports.parseInternalKey = parseInternalKey;
exports.BlockHandle = exports.LookupKey = exports.InternalKeyComparator = exports.kSizeOfUInt32 = exports.Config = exports.kBlockTrailerSize = exports.InternalKeyBuilder = exports.InternalKey = exports.CompressionTypes = exports.VersionEditTag = exports.ParsedInternalKey = exports.kMaxSequenceNumber = exports.kValueTypeForSeek = exports.ValueType = exports.FileType = void 0;

var _DBHelper = require("./DBHelper");

var _Buffer = require("./Buffer");

var _Slice = _interopRequireDefault(require("./Slice"));

var _Coding = require("./Coding");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let FileType;
exports.FileType = FileType;

(function (FileType) {
  FileType[FileType["kLogFile"] = 0] = "kLogFile";
  FileType[FileType["kDBLockFile"] = 1] = "kDBLockFile";
  FileType[FileType["kTableFile"] = 2] = "kTableFile";
  FileType[FileType["kDescriptorFile"] = 3] = "kDescriptorFile";
  FileType[FileType["kCurrentFile"] = 4] = "kCurrentFile";
  FileType[FileType["kTempFile"] = 5] = "kTempFile";
  FileType[FileType["kInfoLogFile"] = 6] = "kInfoLogFile";
})(FileType || (exports.FileType = FileType = {}));

let ValueType;
exports.ValueType = ValueType;

(function (ValueType) {
  ValueType[ValueType["kTypeDeletion"] = 0] = "kTypeDeletion";
  ValueType[ValueType["kTypeValue"] = 1] = "kTypeValue";
})(ValueType || (exports.ValueType = ValueType = {}));

const kValueTypeForSeek = ValueType.kTypeValue; // TODO typedef SequenceNumber as bigint:
// type SequenceNumber = bigint
//
// bigint to buffer:
//   let bnum = (1n << 56n) - 1n
//   Buffer.fromUnknown(bnum.toString(16), 'hex') // <Buffer ff ff ff ff ff ff ff>
//  buf to bigint:
//   let bnum = BigInt(`0x${buf.toString('hex')}`)

exports.kValueTypeForSeek = kValueTypeForSeek;
const kMaxSequenceNumber = (1n << 56n) - 1n;
exports.kMaxSequenceNumber = kMaxSequenceNumber;

class ParsedInternalKey {
  constructor(userKey, sn, valueType) {
    _defineProperty(this, "userKey", void 0);

    _defineProperty(this, "sn", void 0);

    _defineProperty(this, "valueType", void 0);

    if (typeof userKey !== "undefined" && typeof sn !== "undefined" && typeof valueType !== "undefined") {
      this.userKey = userKey;
      this.sn = sn;
      this.valueType = valueType;
    }
  }

}

exports.ParsedInternalKey = ParsedInternalKey;

function packSequenceAndType(seq, t) {
  const bSeq = BigInt(seq);
  (0, _DBHelper.assert)(bSeq <= kMaxSequenceNumber);
  (0, _DBHelper.assert)(t <= kValueTypeForSeek);
  return bSeq << 8n | BigInt(t);
} // Append the serialization of "key" to *result.


function appendInternalKey(buf, key) {
  const sequenceBuf = (0, _Coding.encodeFixed64)(key.sn);
  sequenceBuf.fillInt(key.valueType, 7, 8);
  return _Buffer.Buffer.concat([buf, key.userKey.buffer, sequenceBuf]);
}

let VersionEditTag;
exports.VersionEditTag = VersionEditTag;

(function (VersionEditTag) {
  VersionEditTag[VersionEditTag["kComparator"] = 1] = "kComparator";
  VersionEditTag[VersionEditTag["kLogNumber"] = 2] = "kLogNumber";
  VersionEditTag[VersionEditTag["kNextFileNumber"] = 3] = "kNextFileNumber";
  VersionEditTag[VersionEditTag["kLastSequence"] = 4] = "kLastSequence";
  VersionEditTag[VersionEditTag["kCompactPointer"] = 5] = "kCompactPointer";
  VersionEditTag[VersionEditTag["kDeletedFile"] = 6] = "kDeletedFile";
  VersionEditTag[VersionEditTag["kNewFile"] = 7] = "kNewFile";
  VersionEditTag[VersionEditTag["kPrevLogNumber"] = 9] = "kPrevLogNumber";
})(VersionEditTag || (exports.VersionEditTag = VersionEditTag = {}));

let CompressionTypes; // Returns the user key portion of an internal key.

exports.CompressionTypes = CompressionTypes;

(function (CompressionTypes) {
  CompressionTypes[CompressionTypes["none"] = 0] = "none";
})(CompressionTypes || (exports.CompressionTypes = CompressionTypes = {}));

function extractUserKey(ikey) {
  // if ikey.size === 8, userkey is '' (empty)
  (0, _DBHelper.assert)(ikey.size >= 8);
  return new _Slice.default(ikey.buffer.slice(0, ikey.size - 8));
}

class InternalKey extends _Slice.default {
  // We leave eight bits empty at the bottom so a type and sequence#
  // can be packed together into 64-bits.
  // in c++ , it is (0x1llu << 56) -1, 72057594037927935
  // in javascript , Math.pow(2, 56) - 1 = 72057594037927940, Math.pow(2, 56) - 5 = 72057594037927930
  // so , use 72057594037927935 directly
  static from(slice) {
    const internalKey = new InternalKey();
    (0, _DBHelper.assert)(internalKey.decodeFrom(slice));
    return internalKey;
  }

  constructor(userKey, sn, valueType) {
    super();

    if (typeof userKey !== "undefined" && typeof sn !== "undefined" && typeof valueType !== "undefined") {
      this.buffer = appendInternalKey(this.buffer, new ParsedInternalKey(userKey, sn, valueType));
    }
  }

  get userKey() {
    return extractUserKey(this);
  }

  get type() {
    return this.buffer[this.buffer.length - 1];
  }

  get sequence() {
    const sequenceBuf = _Buffer.Buffer.alloc(8);

    sequenceBuf.fillBuffer(this.buffer.slice(this.buffer.length - 8), 0, 7);
    return (0, _Coding.decodeFixed32)(sequenceBuf);
  }

  decodeFrom(slice) {
    this.buffer = slice.buffer;
    return this.buffer.length > 0;
  }

}

exports.InternalKey = InternalKey;

_defineProperty(InternalKey, "kMaxSequenceNumber", 72057594037927935n);

class InternalKeyBuilder {
  build(sequence, valueType, key) {
    /**
     * encoded(internal_key_size) | key | sequence(7Bytes) | type (1Byte) | encoded(value_size) | value
     * 1. Lookup key/ Memtable Key: encoded(internal_key_size) --- type(1Byte)
     * 2. Internal key: key --- type(1Byte)
     * 3. User key: key
     */
    const sequenceBuf = (0, _Coding.encodeFixed64)(sequence);
    sequenceBuf.fillInt(valueType, 7, 8);
    const slice = new _Slice.default(_Buffer.Buffer.concat([key.buffer, sequenceBuf]));
    return new InternalKey(slice);
  }

} // 1-byte type + 32-bit crc


exports.InternalKeyBuilder = InternalKeyBuilder;
const kBlockTrailerSize = 5;
exports.kBlockTrailerSize = kBlockTrailerSize;

class Config {}

exports.Config = Config;

_defineProperty(Config, "kNumLevels", 7);

_defineProperty(Config, "kL0CompactionTrigger", 4);

_defineProperty(Config, "kL0SlowdownWritesTrigger", 8);

_defineProperty(Config, "kL0StopWritesTrigger", 12);

_defineProperty(Config, "kMaxMemCompactLevel", 2);

_defineProperty(Config, "kReadBytesPeriod", 1048576);

const kSizeOfUInt32 = 4;
exports.kSizeOfUInt32 = kSizeOfUInt32;

class InternalKeyComparator {
  constructor(userComparator) {
    _defineProperty(this, "_userComparator", void 0);

    _defineProperty(this, "oneByte", _Buffer.Buffer.alloc(1));

    this._userComparator = userComparator;
  }

  get userComparator() {
    return this._userComparator;
  }

  getName() {
    return "leveldb.InternalKeyComparator";
  }

  findShortestSeparator(start, limit) {
    // Attempt to shorten the user portion of the key
    const userStart = extractUserKey(start);
    const userLimit = extractUserKey(limit);
    const tmp = new _Slice.default(_Buffer.Buffer.fromUnknown(userStart.buffer));
    this.userComparator.findShortestSeparator(tmp, userLimit);

    if (tmp.size < userStart.size && this.userComparator.compare(userStart, tmp) < 0) {
      // User key has become shorter physically, but larger logically.
      // Tack on the earliest possible number to the shortened user key.
      tmp.buffer = _Buffer.Buffer.concat([tmp.buffer, (0, _Coding.encodeFixed64)(packSequenceAndType(kMaxSequenceNumber, kValueTypeForSeek))]);
      (0, _DBHelper.assert)(this.compare(start, tmp) < 0);
      (0, _DBHelper.assert)(this.compare(tmp, limit) < 0);
      start.buffer = tmp.buffer;
    }
  }

  findShortSuccessor(key) {
    const userKey = extractUserKey(key);
    const tmp = new _Slice.default(_Buffer.Buffer.fromUnknown(userKey.buffer));

    this._userComparator.findShortSuccessor(tmp);

    if (tmp.size < userKey.size && this._userComparator.compare(userKey, tmp) < 0) {
      // User key has become shorter physically, but larger logically.
      // Tack on the earliest possible number to the shortened user key.
      tmp.buffer = _Buffer.Buffer.concat([tmp.buffer, (0, _Coding.encodeFixed64)(packSequenceAndType(kMaxSequenceNumber, kValueTypeForSeek))]);
      (0, _DBHelper.assert)(this.compare(key, tmp) < 0);
      key.buffer = tmp.buffer;
    }
  } // key1 and key2 is internal key buffer


  compare(key1, key2) {
    // Order by:
    //    increasing user key (according to user-supplied comparator)
    //    decreasing sequence number
    //    decreasing type (though sequence# should be enough to disambiguate)
    const userKey1 = extractUserKey(key1);
    const userKey2 = extractUserKey(key2);
    const r = this.userComparator.compare(userKey1, userKey2);
    if (r !== 0) return r;
    const sn1 = (0, _Coding.decodeFixed64)(_Buffer.Buffer.concat([key1.buffer.slice(key1.size - 8, key1.size - 1), this.oneByte]));
    const sn2 = (0, _Coding.decodeFixed64)(_Buffer.Buffer.concat([key2.buffer.slice(key2.size - 8, key2.size - 1), this.oneByte]));
    if (sn1 === sn2) return 0;
    return sn1 > sn2 ? -1 : 1;
  }

} // Attempt to parse an internal key from "internal_key".  On success,
// stores the parsed data in "*result", and returns true.
//
// On error, returns false, leaves "*result" in an undefined state.


exports.InternalKeyComparator = InternalKeyComparator;

function parseInternalKey(internalKey, ikey) {
  try {
    ikey.userKey = extractUserKey(internalKey);

    const snBuf = _Buffer.Buffer.alloc(8);

    snBuf.fillBuffer(internalKey.buffer.slice(internalKey.length - 8), 0, 7);
    ikey.sn = (0, _Coding.decodeFixed64)(snBuf);
    ikey.valueType = internalKey.buffer[internalKey.length - 1];
    return true;
  } catch (e) {
    return false;
  }
}

class LookupKey {
  // We construct a char array of the form:
  //    klength  varint32               <-- start_
  //    userkey  char[klength]          <-- kstart_
  //    tag      uint64
  //                                    <-- end_
  // The array is a suitable MemTable key.
  // The suffix starting with "userkey" can be used as an InternalKey.
  constructor(userKey, sequence) {
    _defineProperty(this, "_internalKeySizeBuf", void 0);

    _defineProperty(this, "_userKeyBuf", void 0);

    _defineProperty(this, "_sequenceBuf", void 0);

    this._userKeyBuf = userKey.buffer;
    this._internalKeySizeBuf = _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(userKey.size + 8));
    this._sequenceBuf = (0, _Coding.encodeFixed64)(sequence);

    this._sequenceBuf.fillBuffer(_Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(kValueTypeForSeek)), 7);
  }

  get buffer() {
    return _Buffer.Buffer.concat([this._internalKeySizeBuf, this._userKeyBuf, this._sequenceBuf]);
  }

  get internalKey() {
    return new _Slice.default(_Buffer.Buffer.concat([this._userKeyBuf, this._sequenceBuf]));
  }

  get memKey() {
    return new _Slice.default(this.buffer);
  }

  get userKey() {
    return new _Slice.default(this._userKeyBuf);
  }

  set userKey(userKey) {
    this._userKeyBuf = userKey.buffer;
    this._internalKeySizeBuf = _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(userKey.size + 8));
  }

}

exports.LookupKey = LookupKey;

class BlockHandle {
  constructor() {
    _defineProperty(this, "offset", void 0);

    _defineProperty(this, "size", void 0);
  }

  static from(buf) {
    const handle = new BlockHandle();
    handle.offset = _DBHelper.varint.decode(buf);
    handle.size = _DBHelper.varint.decode(buf, _DBHelper.varint.decode.bytes);
    return handle;
  }

  get buffer() {
    (0, _DBHelper.assert)(typeof this.offset === "number");
    (0, _DBHelper.assert)(typeof this.size === "number");
    return _Buffer.Buffer.concat([_Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(this.offset)), _Buffer.Buffer.fromUnknown(_DBHelper.varint.encode(this.size))]);
  }

}

exports.BlockHandle = BlockHandle;
//# sourceMappingURL=Format.js.map